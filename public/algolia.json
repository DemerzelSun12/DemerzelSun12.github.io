
[
  
  
  {
    "objectID": "1738612902",
    "permalink": "/post/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/",
    "title": "秋招总结",
    
    "content": "\r前言，写在25年新年开工之前\r博客已经好久没有更新了，好像自从保研结束之后就不写了，文档更多依赖markdown本地化存储，也不需要像本科那样上传博客，然后抱着平板奔走教室复习了，有固定工位了之后还是方便了很多。\n像之前预想的那样，按部就班的读完了两年半的硕士，最后半年的秋招+论文着实压得人喘不过气，虽然秋招的严峻早有耳闻，前两届师兄的痛苦也历历在目，但是真到自己投简历、跑招聘会、线上线下面试笔试的时候，才知道秋招真的来了，而且很难很难。\n不过好在在24年的尾巴解决了工作去向问题，虽然不及往年同届同学的预期，但是在这个萧条的大环境下，能有一份工作就已经很好了。\n24实习\r要论广义的秋招，要回到24年的2月，那时在家刚过完新年，很多本科毕业的同学初五初六就回去准备上班了，我也突然感觉到年后要准备实习了，之前一段实习都没有，要是暑期再没有实习怕不是秋招要g。2月开始刷Leetcode，背八股面经，准备项目写简历。\n已经相隔了一年，很多投递的细节已经分不清了，只记得第一次面试的部门是腾讯的AiLab，面试体验极差，面试的岗位是基础平台开发的Golang的岗位，结果面试官一直在追问Python的相关，还在问Python的GIL。不知道一个写了要Golang的基础平台开发的岗位为什么要全在问Python。当然，估计面评也是烂完了，后面的腾讯的岗位都直接挂。后面还出现了面cisg的暑期实习岗位问为什么没有实习，真是给我整笑了。腾讯傻逼玩意，迟早完蛋，再加上最近的腾讯云nodejs sdk打包被喷，其中的草台班子可见一斑。你们是把马化腾他妈的骨灰打包了吗？。后面秋招也是随便草草投了腾讯的岗位，也没有抱希望，约面了也是直接拒。\n后面面试的有阿里云的岗位，一志愿的是CTO线的Golang开发，约面的是一个做Git的部门，部门的leader和另一个年轻一点的面试官一起面的，可惜自己还是没有太多足够的匹配项目经历，那个组主要的技术栈是grpc，可惜了解的不多，后面也是挂了。\n进入4月中之后，换成了二志愿的基础平台开发岗，换到了CTO线的专有云下的基座组，是做Kubernetes基础平台开发的，面试的流程非常迅速，周一周三周五直接速通了三面，\n",
    
    "date": "2025-02-03 20:01:42",
    "updated": "2025-02-03 20:01:42"
  }
  
  , 
  {
    "objectID": "1653910258",
    "permalink": "/post/java%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/",
    "title": "java常用手册",
    
    "content": "\r常用数据结构\r栈\rimport java.util.Stack;\t//引用栈 //初始化 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;Integer\u0026gt;(); //进栈 stack.push(Element); //出栈 Element e = stack.pop(); //取栈顶值（不出栈） Element e = stack.peek(); //判断栈是否为空 boolean flag = stack.isEmpty(); //获取栈长度 int size - stack.size(); ",
    
    "date": "2022-05-30 11:30:58",
    "updated": "2022-05-30 11:30:58"
  }
  
  , 
  {
    "objectID": "1653910258",
    "permalink": "/post/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "title": "模式识别与深度学习复习笔记",
    
    "content": "\r模式识别\r第一章 绪论\r分类与聚类\r有监督学习：分类 已知：训练样本，每个样本的所属类别。\n​ 目的：利用训练样本的学习分类器，对未知类别样本分类。 2. 无监督学习：聚类 ​ 已知：训练样本 未知：不知道样本的所属类别，甚至类别数量也未知。 目的：利用无监督样本集，发现规律，对当前样本集合中样本进行分类。\n​只有一部分样本有标签：半监督学习，标签不可靠：弱监督学习\n统计模式识别与结构模式识别\r统计方法：将模型看做空间中的一个点，采用解析几何和概率论、数理统计的方法，判别输入模式的类别属性。\n结构方法：将模式看做是由一些基本元素有组织的构成，利用形式语言和自动机理论对模式的结构进行分析和判别。\n鉴别模型与产生式模型\r鉴别模型：不同类别样本在特征空间中处于不同区域，学习$g(x)$，对于不同区域输出不同值。\n产生式模型：模式时随机分布在特征空间中的一个随机矢量，在不同位置出现的概率不同。根据模式在某点出现的概率来判断该点所属的类别。\n第二章 模式识别系统\r模式识别系统构成：先“找到目标”，再“作出判别”。\r综合滤波、投影、压缩等方法，获得相对通用、稳定有效的特征描述子。\nHOG（特征描述子）+SVM行人检测\nHOG：方向梯度直方图，利用图像边缘的方向密度分布描述图像特征\n图片Gamma和颜色的归一化；\n计算梯度；\n构建直方图；\nBlock混叠空间块的归一化；\n构建HOG特征描述子；\nSVM训练；\nSHIFT：尺度不变特征变换，改变旋转角度，图像亮度或拍摄视角，仍然能够得到好的检测效果\n构建多尺度高斯差分DOG边缘图 像序列 找到局部极值点，去除不对称、 不清晰、不稳定的点作为特征点。 找到特征点主方向，梯度直方图 描述 SIFT：尺度不变特征变换，改变旋转角度，图像亮度或拍摄视角，仍然能够得到好的检测效果\n特征的比较与分类\r将待识别样本x分类到与其最相似的类别中\n输入：需要识别的样本x ；\n计算x与所有类别的相似度$s(x, \\omega_i). i=1,...,c$；\n输出：相似度最大的类别$\\omega_j$\n$$\rj = \\arg\\max s(x,\\omega_j)\r$$ 关键问题 ：如何度量样本x与类别 i 的相似程度？\n模板匹配：\r每个类别的“先验知识”就是一个样本（模板）$\\mu_i$\n利用x与模板 $\\mu _i$的相似度，作为x与类别$\\omega …",
    
    "date": "2022-05-30 11:30:58",
    "updated": "2022-05-30 11:30:58"
  }
  
  , 
  {
    "objectID": "1641653608",
    "permalink": "/post/mqtt%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
    "title": "mqtt协议学习记录",
    
    "content": "\rMQTT\rMQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（Publish/Subscribe）模式的轻量级通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布，目前最新版本为v3.1.1。MQTT最大的优点在于可以以极少的代码和有限的带宽，为远程设备提供实时可靠的消息服务。做为一种低开销、低带宽占用的即时通讯协议，MQTT在物联网、小型设备、移动应用等方面有广泛的应用。\n当然，在物联网开发中，MQTT不是唯一的选择，与MQTT互相竞争的协议有XMPP和CoAP协议等，文章末尾会有一个比较和说明。\nMQTT是哪一层的协议？\r众所周知，TCP/IP参考模型可以分为四层：应用层、传输层、网络层、链路层。TCP和UDP位于传输层，应用层常见的协议有HTTP、FTP、SSH等。MQTT协议运行于TCP之上，属于应用层协议，因此只要是支持TCP/IP协议栈的地方，都可以使用MQTT。\nMQTT消息格式\r每条MQTT命令消息的消息头都包含一个固定的报头，有些消息会携带一个可变报文头和一个负荷。消息格式如下：\n固定报文头 | 可变报文头 | 负荷 固定报文头（Fixed Header）\rMQTT固定报文头最少有两个字节，第一字节包含消息类型（Message Type）和QoS级别等标志位。第二字节开始是剩余长度字段，该长度是后面的可变报文头加消息负载的总长度，该字段最多允许四个字节。\n剩余长度字段单个字节最大值为二进制0b0111 1111，16进制0x7F。也就是说，单个字节可以描述的最大长度是127字节。为什么不是256字节呢？因为MQTT协议规定，单个字节第八位（最高位）若为1，则表示后续还有字节存在，第八位起“延续位”的作用。\n例如，数字64，编码为一个字节，十进制表示为64，十六进制表示为0×40。数字321（65+2*128）编码为两个字节，重要性最低的放在前面，第一个字节为65+128=193（0xC1），第二个字节是2（0x02），表示2×128。\n由于MQTT协议最多只允许使用四个字节表示剩余长度（如表1），并且最后一字节最大值只能是0x7F不能是0xFF，所以能发送的最大消息长度是256MB，而不是512MB。\n可变报文头（Variable Header）\r可变报文头 …",
    
    "date": "2022-01-08 14:53:28",
    "updated": "2022-01-08 14:53:28"
  }
  
  , 
  {
    "objectID": "1640950258",
    "permalink": "/post/kubeedge%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/",
    "title": "KubeEdge原理分析",
    
    "content": "可能由于各自的定位不同，K3S更像是一个kubernetes厂商的一个发行版，在边缘计算方面其实是没有摄入细节的。相比起来，KubeEdge目标更明确，除了在kubernetes的方面做了各种异步通信通道，保障offline后的业务连续性之外；还定义了一系列的设备抽象，用来管理边缘设备。而且，其v1.8版本正朝着边缘端服务网格，以及函数式计算等方向发展。总体感觉是基本功能可用，但是更深入的功能有待开发，比如函数式计算这块貌似只有界面，但是使用手册和功能都缺失等。\n这里记录一下学习kubeedge v1.8分支代码的一些理解，便于后续快速查看。其实华为在该项目中文档还算写的比较完备的，官方文档可以参考这里。\n架构\r整体架构图比较明了，在不考虑edgesite的情况下，其架构分为了云端和边缘端。其实可以理解为kubernetes的管理侧和kubelet节点侧（对应edge端）。很多年前rancher就采用这种架构，通过隧道网络通过一个机头来统一纳管位于多个云服务提供商上的计算节点。但是请注意，这里的场景是边缘计算，意味着edge端的网络环境难以保障。\n云边通信\r于是就衍生出了cloud端的cloud Hub与edge端的Edge Hub。这两个模块之间通过websocket或者quic通信，相当于建立了一条底层通信隧道，供k8s和其他应用通信。当然，使用什么协议通信不是重点，重点是如何保障当着之间的链路都无法保障的时候，业务不受到影响，这就是MetaManager的要解决的问题了。\nCloudHub 前面提到cloud端的cloudHub就是一个隧道的server端，用于大量的edge端基于websocket或者quic协议连接上来；没错，这货才是正儿八经的二传手，每天就负责拉皮条。\nEdgeHub 位于edge端运行，是隧道的client端，负责将接收到的信息转发到各edge端的模块处理；同时将来自个edge端模块的消息通过隧道发送到cloud端。\n边缘端\rMetaManager MetaManager模块后端对应一个本地的数据库（sqlLite），所有其他模块需要与cloud端通信的内容都会被保存到本地DB种一份，当需要查询数据时，如果本地DB中存在该数据，就会从本地获取，这样就避免了与cloud端之间频繁的网络交互；同时，在网络中断的情况下，本地的缓存的数据也能够 …",
    
    "date": "2021-12-31 11:30:58",
    "updated": "2021-12-31 11:30:58"
  }
  
  , 
  {
    "objectID": "1639407208",
    "permalink": "/post/go-%E5%88%9D%E5%AD%A6%E8%B8%A9%E5%9D%91/",
    "title": "Go 初学踩坑",
    
    "content": "\r初级篇\r开大括号不能放在单独的一行 在大多数其他使用大括号的语言中，需要选择放置它们的位置。Go 的方式不同。由于自动分号的注入（没有预读），不需要手动添加分号 失败的例子： package main import \u0026amp;#34;fmt\u0026amp;#34; func main() { //error, can\u0026amp;#39;t have the opening brace on a separate line fmt.Println(\u0026amp;#34;hello there!\u0026amp;#34;) } 编译错误：\n/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before { 正确示例：\npackage main import \u0026amp;#34;fmt\u0026amp;#34; func main() { fmt.Println(\u0026amp;#34;works!\u0026amp;#34;) } 未使用的变量 如果有未使用的变量，代码将编译失败。当然也有例外。在函数内一定要使用声明的变量，但未使用的全局变量是没问题的。 如果给未使用的变量分配了一个新的值，代码还是会编译失败。需要在某个地方使用这个变量，才能让编译器编译通过。\nFail:\npackage main var gVar int //not an error func main() { var one int //error, unused variable two := 2 //error, unused variable var three int //error, even though it\u0026amp;#39;s assigned 3 on the next line three = 3 } Compiles error:\n/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not used Works:\npackage main import \u0026amp;#34;fmt\u0026amp;#34; func main() { …",
    
    "date": "2021-12-13 14:53:28",
    "updated": "2021-12-13 14:53:28"
  }
  
  , 
  {
    "objectID": "1623514428",
    "permalink": "/post/%E5%8D%97%E5%9B%BD%E7%BA%AA%E8%A1%8C%E4%B8%89/",
    "title": "南国纪行（三）",
    
    "content": "\r前言\r前两篇主要回忆了一些在深圳的特定的所见所闻，这篇谈谈我为什么来深圳，交换的感受，以及深圳带给我的。\n交换——心血来潮\r11月看到了今日哈工大上出现了哈深的交换项目，正好18级计算机科学与技术有9个名额，本来想报一下去哈深看看，但是看了一下哈深的执行教学计划，发现缺少《编译原理》和《模式识别与深度学习》这两门课，如果我要去交换的话，大四春回来还需要补修这两门课，在询问了学校教务处关于毕业的要求之后，我感觉可能需要用晚拿双证一个月来换取交换的机会了，不过想到20春的时候，毕业班的同学可以提前考试甚至变报告，另外交换期间的学分绩不会变动，所以我的保研成绩就只算前五个学期的了。权衡了一下利弊，我决定还是报名吧，我知道再卷一学期的成绩一定会把我弄得身心俱疲，不如就此好好放松一下，也留有更多时间思考一下自己究竟要做什么。\n报名——心情忐忑\r毕竟是赌上了自己的保研资格，要赌大三下的题足够难，普遍学分绩会下降，而且自己放弃了再对学分绩提高的机会，所以在等待报名结果的几周里，真的很着急。不过幸好最后也是选上了，讽刺的是，选上的同学里，除了英才的几位同学和我之外，剩下的同学都是转专业进来的，看来怎么回事大家心里应该都明白的。\n深圳——体验\r第一次结识深圳校区还是在我高考那年，那年深圳校区第一次本科生独立出来招生，虽说我的成绩无论是去本部还是深圳都是可以保第一专业的，但是最后权衡利弊还是来了本部，当时的想法是本科打好基础，\n",
    
    "date": "2021-06-12 16:13:48",
    "updated": "2021-06-12 16:13:48"
  }
  
  , 
  {
    "objectID": "1622750982",
    "permalink": "/post/%E5%8D%97%E5%9B%BD%E7%BA%AA%E8%A1%8C%E4%BA%8C/",
    "title": "南国纪行（二）",
    
    "content": "\r前言\r虽然本篇的写作日期是2021-06-03，本来是打算在6月2日去深圳文和友玩了之后写的游记，但是紧跟着广东省的疫情出现，我不得不提前了回家的计划，紧接着的是办理各种离校手续，在6.9这天甚至出现了导员与学校领导关于是否让我们回哈尔滨的不同消息，闹了半天才真正解决。在此要十分感谢深圳校区辅导员辛老师的努力，在大学的三年时间里，第一次感受到了来自辅导员的关心与关怀，她是真正能把学生放在心上的辅导员老师，真的很尊敬她。\n这篇游记还是按照原计划写一写在深圳文和友的所见所闻吧，然后深圳的三个半月的生活体验写在下一篇纪行里面吧。\n现在是6月10日，我在机场附近的宾馆写下以上的文字，因为要赶明天早上7点半的飞机，所以今天也会睡的比较早吧。\n文和友\r文和友是一个长沙的综合商场的品牌，不过装修上很有特点，仿的是80 90年代的老长沙的风格，里面除了很多长沙地方特色的小吃，更多的是那个年代的一些独有的门店。 不过据老长沙人（DDJ）所说，长沙人基本上很少去文和友，导致文和友更像是一个外地人来长沙的打卡景点。四月文和友在深圳开了一家新店，茶颜悦色也入驻了，据说当天排号达到了5w多人，幽兰拿铁被炒到了300一杯，不过在我去的当天，由于前几日广州刚出现疫情，人不是很多，茶颜悦色排队也不到10人，基本上是去了就能点单，拍照也没有很多人，整体更像上个世纪的感觉了，总之是不错的体验。\n从大学城地铁站到老街站，需要转两次，花了快一个小时才到了门口，在地铁上我预约的座位，一直显示前方有98桌等待，我还以为要等到晚上，结果到了才发现，根本没有人，直接就进去了。\n进去是一个短短的走廊，一家花店和几家忘了是什么的店铺了，好像有一家豆浆店。\n进去后的一楼就是筒子楼的天井，中间是类似大排档的摊位，上方楼的墙壁上挂着大大小小的招牌，站在楼梯上看，颇有弄堂的内味了。\n一楼实在是太热了，我直接就去了二楼，二楼就凉快了很多，上楼梯之后就是一条曲曲折折的巷子，两侧是各式各样的老式店铺，主要是各种小吃和饮品。\n万年不主动和饮品的老直男也决定点一杯尝尝，选了店铺的招牌芝士芒芒，应该不会踩雷吧，店里面除了我之外并无顾客，真正的门可罗雀。和老板攀谈起来，老板说由于广州的疫情，最近一阵子根本没有人，文和友刚开业的时候排队可以到很远，很强的对比。我也不知这里的芝士芒芒是否正宗，下层是芒果肉捣成的泥混合着茶和沙冰，最上面一层芝 …",
    
    "date": "2021-06-03 20:09:42",
    "updated": "2021-06-03 20:09:42"
  }
  
  , 
  {
    "objectID": "1622750982",
    "permalink": "/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/",
    "title": "数据库笔记",
    
    "content": "\r前言\r深圳校区的《数据库系统》课程笔记。本部的数据库一直饱受诟病的是太依赖mooc了，不是说mooc不好，计算机本来就是一门发展极快的学科，mooc一录用好几年的情况实在不适合用在计算机学科上，我们希望能学到最新的知识，或者能与当前的技术做结合，第一节课之后，觉得深圳这边讲课的拓展比本部好很多。希望在这边能学到在本部学不到的知识。\n一、数据库系统基本概念\rTable的常用语： 列/字段/属性/数据项 行/元组/记录 表标题（格式） 表内容（值） Table中描述了一批相互有关联关系的数据$\\rightarrow$关系。第二章中给以严格定义：关系模型与关系运算\n数据库：相互之间有关联关系的Table的集合\n数据库系统(工作环境) 数据库(DB): Database 数据库管理系统(DBMS): Database Management System 数据库应用(DBAP): DataBase Application\n数据库管理员(DBA): DataBase Administrator\n计算机基本系统 数据库管理系统不包括数据库管理员，数据库系统包括数据库管理员。\n数据库管理系统(系统软件):从用户角度看DBMS的功能\n数据库定义: 定义数据库中Table的名称、标题(内含的属性名称及对该属性的值的要求)等。\nDBMS提供一套数据定义语言(DDL:Data Definition Language)给用户； 用户使用DDL描述其所要建立表的格式； DBMS依照用户的定义，创建数据库及其中的Table。 数据库操纵: 向数据库的Table中增加/删除/更新数据及对数据进行查询、 检索、统计等。\nDBMS提供一套数据操纵语言(DML:Data Manipulation Language)给用户； 用户使用DML描述其所要进行的增、删、改、查等操作； DBMS依照用户的操作描述，实际执行这些操作。 数据库控制: 控制数据库中数据的使用\u0026amp;mdash;哪些用户可以使用,哪些不可以 DBMS提供一套数据控制语言(DCL:Data Control Language)给用户\n用户使用DCL描述其对数据库所要实施的控制 DBMS依照用户的描述，实际进行控制 数据库维护: 转储/恢复/重组/性能监测/分析…\nDBMS提供一系列程序(实用程序/例行程序) 给用户 在这些程序中提供了对数据库维 …",
    
    "date": "2021-06-03 20:09:42",
    "updated": "2021-06-03 20:09:42"
  }
  
  , 
  {
    "objectID": "1620917608",
    "permalink": "/post/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/",
    "title": "UNIX环境高级编程阅读笔记",
    
    "content": "\r前言\r张老师推荐阅读的两本书之一，打算用一个月到两个月之间的时间，初步过完《UNIX环境高级编程》与《UNIX网络编程第三版第一卷》，之后继续阅读其他关于UNIX底层的书籍。\n一、UNIX基础知识\r所有操作系统都提供基础的服务：执行新程序、打开文件、读文件、分配存储区、获取当前时间等。\n1.1 UNIX 体系结构\r操作系统控制计算机硬件资源，提供程序运行环境的“软件”称为操作系统的内核。内核的接口称为系统调用。 公共函数库建立在系统调用的接口之上；应用程序可以使用公共函数库，也可以使用系统调用。 shell 是一个特殊的应用程序，为运行其他应用程序提供接口。 1.2 文件和目录\r文件系统 UNIX文件系统是目录和文件的一种层次结构，所有的起点为根目录，名称为字符“/”。\n目录：包含目录项的文件，逻辑上认为目录项包含文件名和文件属性信息。文件属性：文件类型（普通文件 or 目录）、文件大小、文件所有者、文件权限、文件最后修改时间等。\nstat和fstat函数返回包含所有文件属性的一个信息结构。\n文件名 斜线（/）和空字符不允许出现在文件名中，创建目录会自动创建两个文件名：（.）指向当前目录和（..），在最高层次的根目录中，二者相同。\n路径名 斜线开头路径为绝对路径，否则为相对路径。根名字是特殊的绝对路径名，不包含文件。\n工作目录 所有相对路径从当前目录开始解释。进程可以使用chdir函数更改其工作目录。\n1.3 输入输出\r文件描述符 文件描述符为一个小的非负整数，内核用于标识一个特定进程正在访问的文件。当内核打开现有文件时或创建新文件时，会返回文件描述符。\n标准输入、标准输出、标准错误 每当运行新的程序时，所有的shell都会为其打开3个文件描述符，即标准输入、标准输出、标准错误。一般情况下，三个描述符的链接都指向终端，可以使其中一个或三个重定向到某个文件。例如\n# 执行 ls 命令，将输出重定向到名为 file.txt 的文件 ls \u0026amp;gt; file.txt 缓冲的IO 函数 open、read、write、lseek 以及 close提供了不带缓冲区的IO，这些函数都使用文件描述符。\n标准IO 标准IO为不带有缓冲的IO函数提供了一个带缓冲的接口。使用标准IO函数无需担心选择最佳缓冲区的大小。\n1.4 程序和进程\r程序：程序是存储在磁盘的某个目录中的可执行文 …",
    
    "date": "2021-05-13 14:53:28",
    "updated": "2021-05-13 14:53:28"
  }
  
  , 
  {
    "objectID": "1619016808",
    "permalink": "/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "title": "分布式系统复习笔记",
    
    "content": "\r一、分布式系统介绍\r1.1 分布式系统\r分布式系统定义为其中联网计算机上的组件仅通过传递消息来通信和协调其动作的系统。\n特点： 并发：多进程、多线程之间并发，共享资源 无全局时钟：进程间通过消息传递协作 单节点失败问题：某些进程失败不会被其他进程知晓 1.2. 分布式系统挑战\r异质性： 中间件：提供程序抽象以掩盖底层(网络、硬件、操作系统、编程语言)不同的软件 移动代码：可以从一台计算机传输到另一台计算机并在目标计算机上运行的程序代码。 示例：Java Applet。Java虚拟机（JVM）提供了一种使代码在各种主机上可执行的方法。 开放性： 单个计算机系统的开放性：哪些接口可以extended or implemented 分布式系统开放性：可以添加新资源共享服务并使其可供各种客户端程序使用的程度。 安全性： 机密性：防止泄露给未经授权个体 完整性：防止更改、破坏，方法之一，校验和 可用性：防止干扰访问资源的手段。 易扩展性： 物理资源开销 性能下降 防止软件执行中的超时 避免性能瓶颈：设计算法避免 失败处理问题: 失败的检测：只有一部分的失败可以被检测到 掩盖失败：部分被检测的失败，可以被掩盖或减轻损失 容忍失败：Internet大部分服务容忍失败 从失败处恢复：从软件层面设计，当服务器崩溃后，永久性数据可被恢复或回滚 冗余组件：可通过冗余组件容忍失败。 并发性： 多线程并发使用同一资源，考虑性能表现\n透明性： 访问透明性：本地资源和远程资源可以通过相同操作访问 地点透明性：无需知晓物理地址、网路地址即可访问资源 并发透明性：多个进程并发操作共享资源互不干扰 复制透明性：使用户可以使用多个资源实例来提高可靠性和性能，而无需用户或应用程序程序员了解副本。 故障透明性：隐藏故障，即使硬件或软件组件出现故障，用户和应用程序也可以完成其任务。 移动透明性：允许在系统内移动资源和客户端，而不会影响用户或程序的操作。 性能透明性：允许重新配置系统以随负载变化而提高性能。 伸缩透明性：允许系统和应用程序按比例扩展，而无需更改系统结构或应用程序算法。 服务质量 可靠性 安全性 性能 易扩展性 二、系统模型\r2.1 物理模型\r物理模型是分布式系统底层硬件元素的表示，它从所用计算机和网络技术的特定细节中抽象出来。\n三代分布式系统：\n早期的分布式系统 由于使用局域网技术而在1970 …",
    
    "date": "2021-04-21 14:53:28",
    "updated": "2021-04-21 14:53:28"
  }
  
  , 
  {
    "objectID": "1614783208",
    "permalink": "/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/",
    "title": "《分布式系统概念与设计》阅读笔记",
    
    "content": "\r前言\r系统的学习一下分布式系统的知识，先从这本书看吧。把基础的概念学好。\n一、系统模型\r1.1 简介\r提出三个重要且互补的解释方法，以便有效的描述分布式系统的设计：\n物理模型：考虑组成系统的计算机和设备的类型以及他们的互连，不涉及特定的技术细节。 体系结构模型：从系统的计算元素执行的计算和通信任务方面描述系统。计算元素：单个计算机或通过网络互连的计算机集合。CS架构和P2P结构是常见的体系结构模型。 基础模型：采用抽象的观点描述大多数分布式系统面临的单个问题的解决方案。 分布式系统中没有全局时间的概念，不同计算机的时钟未必有相同的时间。进程间所有通信通过消息完成。\n计算机网络上的消息通信会受到延迟的影响，这些问题从三个模型讨论：\n交互模型：处理分布式系统的性能问题并解决在分布式系统中设置的时间约束的困难，例如消息传送的时间约束。 故障模型：给出进程和通信通道故障的一个精确规约。定义了可靠的通信和正确的进程。 安全模型：讨论进程和通信通道的各种可能的威胁。 1.2 物理模型\r四、进程间通信\r分布式应用需要组播，即使没有IP组播的底层支持也必须提供组播。通常可以通过在TCP/IP网络上构建一个覆盖网络提供对组播的支持。\n消息传递接口（Message Passing Interface）是一个标准，为一组具有同步和异步支持的消息传递操作提供API。\nUDP的应用程序接口提供了消息传递抽象，TCP的应用程序接口提供了进程对之间的双向流抽象。\n4.1 互联网协议API\r4.1.1 进程间通信\r同步和异步通信 每个消息目的地与一个队列相关。发送进程将消息添加到远程队列中，接收进程从本地队列中移除消息。发送进程和接收进程在每个消息上同步。\n同步形式通信：发送进程和接收进程在每个消息上同步，此时send和receive都是阻塞操作。 异步形式通信：send操作非阻塞，只要消息被复制到本地缓冲区，发送进程就可以继续其他处理，消息的传递与发送进程并行进行；receive操作有阻塞型和非阻塞型，在不阻塞的receive操作中，接收进程在发出receive操作后可以继续执行其程序，此时receive操作在后台提供一个缓冲区，但必须通过轮循或中断独立接收缓冲区已满的通知。 消息目的地 本地端口是计算机内部的消息目的地。\n可靠性 如果一个点对点消息服务在丢失了“合理”数量的数据包后，仍能保证 …",
    
    "date": "2021-03-03 14:53:28",
    "updated": "2021-03-03 14:53:28"
  }
  
  , 
  {
    "objectID": "1614633208",
    "permalink": "/post/glusterfs%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/",
    "title": "GlusterFS分布式文件系统原理",
    
    "content": "\r概览\r以 Docker 为代表的容器技术在云计算领域正扮演着越来越重要的角色，甚至一度被认为是虚拟化技术的替代品。企业级的容器应用常常需要将重要的数据持久化，方便在不同容器间共享。为了能够持久化数据以及共享容器间的数据，Docker 提出了 Volume 的概念。单机环境的数据卷难以满足 Docker 集群化的要求，因此需要引入分布式文件系统。目前开源的分布式文件系统有许多，例如 GFS，Ceph，HDFS，FastDFS，GlusterFS 等。GlusterFS 因其部署简单、扩展性强、高可用等特点，在分布式存储领域被广泛使用。本文主要介绍了如何利用 GlusterFS 为 Docker 集群提供可靠的分布式文件存储。\nGlusterFS 分布式文件系统简介\rGlusterFS 概述\rGlusterFS (Gluster File System) 是一个开源的分布式文件系统，主要由 Z RESEARCH 公司负责开发。GlusterFS 是 Scale-Out 存储解决方案 Gluster 的核心，具有强大的横向扩展能力，通过扩展能够支持数PB存储容量和处理数千客户端。GlusterFS 借助 TCP/IP 或 InfiniBand RDMA 网络将物理分布的存储资源聚集在一起，使用单一全局命名空间来管理数据。GlusterFS 基于可堆叠的用户空间设计，可为各种不同的数据负载提供优异的性能。\nGlusterFS 总体架构与组成部分如图1所示，它主要由存储服务器（Brick Server）、客户端以及 NFS/Samba 存储网关组成。不难发现，GlusterFS 架构中没有元数据服务器组件，这是其最大的设计这点，对于提升整个系统的性能、可靠性和稳定性都有着决定性的意义。\nGlusterFS 支持 TCP/IP 和 InfiniBand RDMA 高速网络互联。 客户端可通过原生 GlusterFS 协议访问数据，其他没有运行 GlusterFS 客户端的终端可通过 NFS/CIFS 标准协议通过存储网关访问数据（存储网关提供弹性卷管理和访问代理功能）。 存储服务器主要提供基本的数据存储功能，客户端弥补了没有元数据服务器的问题，承担了更多的功能，包括数据卷管理、I/O 调度、文件定位、数据缓存等功能，利用 FUSE（File system in User Space）模块将 GlusterFS 挂载到本地文件系统之上，实现 POSIX 兼容的方式来访问系统数据。\n",
    
    "date": "2021-03-01 21:13:28",
    "updated": "2021-03-01 21:13:28"
  }
  
  , 
  {
    "objectID": "1614539608",
    "permalink": "/post/curl%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
    "title": "curl使用指南",
    
    "content": "\r前言\rcurl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。\n它的功能非常强大，命令行参数多达几十种。配置docker的时候接触到的，记录一下。（深度搜索的学习策略？）\n不带有任何参数\r此时curl 就是发出 GET 请求。\n$ curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。\n-A\r-A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。\n$ curl -A \u0026amp;#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36\u0026amp;#39; https://google.com 上面命令将User-Agent改成 Chrome 浏览器。\n$ curl -A \u0026amp;#39;\u0026amp;#39; https://google.com 上面命令会移除User-Agent标头,也可以通过-H参数直接指定标头，更改User-Agent。\n$ curl -H \u0026amp;#39;User-Agent: php/1.0\u0026amp;#39; https://google.com -b -b\r-b参数用来向服务器发送 Cookie。\n$ curl -b \u0026amp;#39;foo=bar\u0026amp;#39; https://google.com 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。\n$ curl -b \u0026amp;#39;foo1=bar;foo2=bar2\u0026amp;#39; https://google.com 上面命令发送两个 Cookie。\n$ curl -b cookies.txt https://www.google.com 上面命令读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。\n-c\r-c参数将服务器设置的 Cookie 写入一个文件。\n$ curl -c cookies.txt …",
    
    "date": "2021-02-28 19:13:28",
    "updated": "2021-02-28 19:13:28"
  }
  
  , 
  {
    "objectID": "1613941168",
    "permalink": "/post/%E5%8D%97%E5%9B%BD%E7%BA%AA%E8%A1%8C%E4%B8%80/",
    "title": "南国纪行（一）",
    
    "content": "\r跋\r博主是18年高考的，经历了阴差阳错的报考，选择了哈工大本部的计算机系。按照当年黑龙江的录取分数线，进入深圳校区的计算机系就读也是不成问题的，谁知这两年深圳校区的分数线也是水涨船高，当年稳进计算机的分数变成了学校的分数线。看着深圳同学“炫耀”的上床下桌，住本部53年老公寓的我也总是不停的恰柠檬。不过好说，20秋的时候，学校突然有了本部和深圳交换的项目，查了查两个校区的培养方案，在那边我只能修两门专业课，剩下的两门课还要等到大四春回来补修，还要晚拿一个月的两证。看样子代价有点大，不过呢，干就完了，学分绩已然是不担心的了，躺平了也不失一种放松，旅游一样的半年，也是给自己一个放松的机会了。\n出行\r早早的就买了飞机票，也有直达的航班，不过达到的时间是在半夜，不方便入住，于是选择了北京中转的航班。由于是第一次转机，选择了有三个小时空余的转机航班，也被因此朝姐嘲笑太小心谨慎了。不过，这个也成伏笔了。\n早早的到了机场，由于前一天南航app的值机程序出现了bug，把我之前选的位置顶没了，自动换到了后一排的中间，坐在了南哥后面，朝姐旁边，也好。我不是一个喜欢看综艺的人（实在是脸盲，名字对不上人），看电影又怕头晕，索性还是把前两天没看完的小说看完吧。\n起飞没啥问题，不过旁边的朝姐一直希望我能一起看，算是找一个共同吐槽的弹幕人吧，但是我真的脸盲，而且经常get不到综艺的点，就\u0026amp;hellip;不占用另一半耳机了，我还是看书吧。\n早早的就落地了，南哥有亲戚请吃饭，所以就先走了，曦姐要赶比我们早一班的飞机，自然也不能像我们三个（朝姐、sdl和我）一样悠闲，办完了托运手续，开始了在大兴的闲逛，话说大兴的人是真的少，基本上看不到几个人，本来打算恰开封菜的，安检外面的开封菜样品实在过于贫瘠，sdl提议过了安检再找，反正开封菜有很多家，于是我们愉快的去安检了，然后伏笔就来了。\n安检后，我们的登机口是B29，这一侧地图上确实显示有一家开封菜，不过找了半天，转了好久，前前后后确认了两遍，最终得出结论：B004号的开封菜被满记甜品取代了，最后我们三个中午恰的是味千拉面，之后去候机，正好是12点，看样子三个小时的转机也算是恰好利用（浪费）了。\n第二趟航班登机时，我瞄见了驾驶室的机长把腿搭在了操纵杆上，当时心生不妙，这放荡不羁的机长莫非开飞机也很狂野，不出所料，还没过20分钟，我就晕的不行了，本来就是起早赶 …",
    
    "date": "2021-02-21 20:59:28",
    "updated": "2021-02-21 20:59:28"
  }
  
  , 
  {
    "objectID": "1610621608",
    "permalink": "/post/docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
    "title": "Docker学习记录",
    
    "content": "\r前言\r为了给hitreport写CI，github的CI实在用不明白了，于是乎自己学一下Docker，记录一下。\nDocker是一个开源项目，最开始是dotCloud公司内部的一个业余项目，基于Go语言实现。后来项目加入了Linux基金会，使用Apache 2.0协议，代码在Github维护。\nDocker的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器（LXC）等技术。在LXC的基础上Docker进行了进一步封装，让用户不关心容器的管理，使操作简便。操作Docker容器类似于操作一个快速轻量级的虚拟机。\nDocker与传统虚拟化不同的地方在于，Docker是在操作系统层面实现虚拟化，直接复用本地主机的操作系统，而传统方式是在硬件层面实现虚拟化。\nDocker基本概念\r镜像 Image\rDocker镜像是一个只读的模板，例如，一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装Apache或者用户需要的其他应用程序。\n镜像可以用来创建Docker容器。\n容器 Container\rDocker容器用来运行应用。容器是从镜像创建的运行实例，容器可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的。\n容器可以看做一个简易的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）并且可以在其中运行相应的应用程序。\n注：镜像是只读的，容器在启动时创建一层可写层作为最上层。\n仓库 Repository\r仓库是集中存放镜像文件的场所。有时候会将仓库和仓库注册服务器混为一谈。实际上，仓库注册服务器上往往存放多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签。\n仓库分为公开仓库（public）和私有仓库（private），用户创建自己的镜像之后使用push命令上传到公有或者私有仓库，在另一台机器上使用这个镜像的时候，只需要从仓库上pull即可。\n注：Docker仓库的概念类似git，注册服务器可以理解为Github托管服务。\n常用命令\r获取镜像\r例：\ndocker pull ubuntu:20.04 相当于\nsudo docker pull registry.hub.docker.com/ubuntu:20.04 即从registry.hub.docker.com的ubuntu仓库中下载标记为20.04的镜 …",
    
    "date": "2021-01-14 10:53:28",
    "updated": "2021-01-14 10:53:28"
  }
  
  , 
  {
    "objectID": "1608393208",
    "permalink": "/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E9%A2%84%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "title": "计算机组织与体系结构期末预习笔记",
    
    "content": "\r前言\r本学期最绝望的一门课，没有之一，建议学弟学妹们不要选这门课，真的内容多又难，而且作业多，签到多，选修不做实验真的什么都不懂，建议选修cv专业课和认知神经科学原理，真的很赚。\n一、计算机系统概论\r1.1 计算机系统简介\r计算机系统： 硬件：计算机实体 软件：具有各类特殊功能的信息 系统软件：管理整个计算机系统：语言处理程序、操作系统、服务型程序、数据库管理系统、网络软件。 应用软件：按任务的各种应用程序。 计算机解题过程： 高级语言$\\xrightarrow{翻译}$目标程$\\xrightarrow{运行}$结果\n计算机系统结构层次 高级语言$\\rightarrow$虚拟机器$M_4$，用编译程序翻译为汇编语言程序 汇编语言$\\rightarrow$虚拟机器$M_3$，用汇编程序翻译成机器语言程序 操作系统$\\rightarrow$虚拟机器$M_2$，用机器语言解释操作系统 机器语言$\\rightarrow$实际机器$M_1$，用微指令集解释机器指令 微指令系统$\\rightarrow$微程序机器$M_0$，由硬件直接执行微指令 1.2 计算机基本组成\r1.2.1 冯诺依曼计算机特点\r计算机由五大部件组成\n存储器：存放数据和程序 运算器：算术运算和逻辑运算 控制器：指挥程序运行 输入设备：将信息转换为机器可以识别的形式 输出设备：将机器运算结果转换为人可识别的形式 指令和数据以同等地位与存储器，可按照地址寻访\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序\n以运算器为中心\n1.2.2 现代计算机\r现代计算机一存储器为核心，运算器ALU + 控制器CU = CPU，主存 + 辅存 = 存储器，主存 + CPU = 主机，输入设备 + 输出设备 = I/O设备，主机 + I/O设备 = 硬件。\n1.2.3 计算机工作步骤\r上机前准备\n建立数学模型 确定计算方法 编制解题程序 程序：运算的全部步骤 指令：每一个步骤 计算机解题过程\n存储器的基本组成 存储单元：存放一串二进制代码 存储字：存储单元中二进制代码的组合 存储字长：存储单元中二进制代码的组合，每个存储单元会被赋予一个地址号 按地址访问 MAR：存储器地址寄存器，反应存储单元的个数 MDR：存储器数据寄存器，反应存储字长 eg：MAR=4位，MDR=8位，则存储单元有16个，每个的存储字长为8位。 …",
    
    "date": "2020-12-19 15:53:28",
    "updated": "2020-12-19 15:53:28"
  }
  
  , 
  {
    "objectID": "1608393208",
    "permalink": "/post/%E8%A7%86%E5%90%AC%E8%A7%89%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%90%AC%E8%A7%89%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "title": "视听觉信号处理听觉复习笔记",
    
    "content": "\r前言\r教务处的垃圾排课，非要单双周上课，结果听觉上完课的两天后就考试，就nm离谱，被迫现在开始复习。\n总述\r课程主要内容：\n语音识别(Speech Recognition) 语音编码(Speech Coding) 一、语音的声学表示\r1.1 语音的声学特性\r语音以声波的形式在空气中传播，声波是纵波，振动方向与传播方向一致。\n1.2 声波的基本物理量\r频率：人耳对声波频率高低的感觉与实际频率近似成对数关系，即“分贝”的由来。基频：60Hz~500Hz。\n振幅:\n用声压或声强表示声音的强度 声压p用来度量由于声波的传播导致的气压的变化，单位帕斯卡 声强 I 为单位时间内通过与声波传播方向垂直的某一单位面积上的声能的平均值，单位$\\left.W /m^2 \\right.$. 最小声压：闻阈，约为$2\\times 10^{-5}Pa$； 最大声压：痛阈，约为$200Pa$. 分贝： 以闻阈$P_0$为基准，单位dB， 依照声压定义分贝：$L=20\\log_{10}\\left(P\\left. / P_0\\right.\\right)\\left(\\mathrm{dB}\\right)$ 依照声强定义分贝：$L=10\\log_{10}\\left(I\\left. / I_0\\right.\\right)\\left(\\mathrm{dB}\\right)$ 闻阈相当于 $0\\mathrm{dB}$，痛阈相当于 $140\\mathrm{dB}$，人讲话时，一米远处的声强大约为$60dB \\sim80dB$。 共振和共振峰 共振：物体受迫振动时，所加驱动频率等于物体固有频率时，物体以最大振幅振动。 元音的音色和区别特征主要取决于声道的共振峰特性。 二、语音的数字信号表示\r2.1 数字信号处理\r就nm躲不过了呗。\n离散时间信号与系统 在时间上离散，只在某些不连续的规定瞬间给出函数值。幅值连续—抽样信号，幅值离散—数字信号。 通常函数值离散时刻之间的间隔是均匀的，以序列 $x\\left(n\\right)\\; \\left(n=0, \\pm1,\\pm2,\\cdots\\right)$表示。 离散信号序列的基本运算 序列中同序号的数值逐项运算构成一个新序列。\n运算 规则 加 $z\\left(n\\right) = x\\left(n\\right)+y\\left(n\\right)$ …",
    
    "date": "2020-12-19 15:53:28",
    "updated": "2020-12-19 15:53:28"
  }
  
  , 
  {
    "objectID": "1606082502",
    "permalink": "/post/2020%E7%A7%8B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98/",
    "title": "2020秋机器学习期末试题",
    
    "content": "\r前言\r今年的题目相对于去年(2019秋)的要简单许多，不过有好多类似的题目。\n2019秋机器学习期末考试题目\r信息增益是什么？举例说明为什么信息增益好。决策树分界面是否为线性，举例说明。 最小错误概率下的最优分类方法并证明。 什么是过拟合，决策树和SVM如何避免过拟合。 在第二题的分类方法下，假设类概率分布式伯努利分布，类条件概率分布是协方差相等的两个高斯分布，求分界面方程，求类后验概率。 逻辑回归优化目标函数。从交叉熵的角度理解，交叉熵的两个概率分布分别是什么？ PCA推导，PCA应用举例(2个)。 GMM模型优化目标函数，EM算法主要步骤。在做实验时，协方差矩阵行列式为0的原因，如何解决。 在低维空间中线性不可分的样本，为什么在高维空间中线性可分，举例说明，在实验中有无应用？ 机器学习中内积的应用举例(3个)，解释他们的意义。 2020秋机器学习期末考试题目\r样本的类别标签Y和某个属性$A_1$（二者可看成随机变量），二者之间的互信息在决策树构建中可以指导选择属性。 互信息的定义？ 依赖互信息（信息增益）选择属性的目的？有什么好处？ 如何避免决策树的过拟合？ Y为表示样本类别的随机变量（假定2类，$Y=0$，$Y=1$），X为样本样例特征向量，对X的错误分类会导致损失，将真实类为1的样本判断为类0造成的损失为a，反之为b，如下表所示。 Y 0 1 0 0 a 1 b 0 期望损失最小意义下的分类准则是什么？ 用图例说明之。 三问 给出线性可分时SVM优化的目标函数和约束条件。 SVM对线性不可分数据的解决方案。 SVM中支持向量有什么意义。 三问 本课程中模型参数估计主要有哪些方法？ 它们的区别？ 什么情况下会获得趋于一致的结果。 两问 为什么Logistic优化的目标函数为条件似然$\\log \\left(Y|X\\right) $，而非$\\log \\left(X,Y\\right)$？ 推导如何从Logistic回归获得样本空间的决策面。 两问 从信号重建的角度推导PCA； 如何使用PCA压缩信号？ 三问 k-Means算法流程； 给出K-Means的优化目标函数； 与EM算法的相似性与不同点。 本课程第一个实验是单变量非线性回归问题，若把其看做线性回归问题，用公式给出你的解决方案。 ",
    
    "date": "2020-11-22 22:01:42",
    "updated": "2020-11-22 22:01:42"
  }
  
  , 
  {
    "objectID": "1599491074",
    "permalink": "/post/pat%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%BA%8C/",
    "title": "PAT刷题记录二",
    
    "content": "\r1004 Counting Leaves\r题目\rA family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.\nInput Specification\nEach input file contains one test case. Each case starts with a line containing $0",
    
    "date": "2020-09-07 15:04:34",
    "updated": "2020-09-07 15:04:34"
  }
  
  , 
  {
    "objectID": "1599343302",
    "permalink": "/post/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/",
    "title": "朴素贝叶斯法",
    
    "content": "\r一、基本形式\r朴素贝叶斯法(naive Bayes)是基于贝叶斯定理与特征条件独立假设的分类方法。 对于给定的训练模型，首先基于特征条件独立假设学习输入输出的联合概率分布；然后基于此模型，对于给定的输入 $x$，利用贝叶斯定理求出后验概率最大的输出 $y$。\n1.1 朴素贝叶斯法的基本方法\r设输入空间 $\\mathcal{X}\\in \\textbf{R}^n$ 为 $n$ 维向量的集合，输出空间为类标记集合 $\\mathcal{Y}=\\left\\{c_1,c_2,\\cdots,c_K\\right\\}$。输入为特征向量 $x\\in \\mathcal{X}$，输出为类标记(class label) $y\\in \\mathcal{Y}$。$X$ 是定义在输入空间 $\\mathcal{X}$ 上的特征向量，$Y$ 是定义在输出空间 $\\mathcal{Y}$ 上的随机变量。$P\\left(X,Y\\right)$ 是 $X$ 和 $Y$ 的联合概率分布。训练数据集 $T=\\left\\{\\left(x_1,y_1\\right),\\left(x_2,y_2\\right),\\cdots ,\\left(x_N,y_N\\right)\\right\\}$ 由 $P\\left(X,Y\\right)$ 独立同分布产生。\n由于我们的目标是计算 $P\\left(Y|X\\right)$，又贝叶斯定理可知， $$ P\\left(Y|X\\right)=\\cfrac{P\\left(X,Y\\right)}{P\\left(X\\right)}=\\cfrac{P\\left(X|Y\\right)\\cdot P\\left(Y\\right)}{\\sum_{k}{P\\left(X=x_i|Y\\right)P\\left(Y\\right)}} $$ 由于分母的 $P\\left(X\\right)$ 是常数，所以只需要计算分子即可，即 $$ P\\left(Y=c_k\\right),\\ k=1,2,\\cdots,K $$ $$ P\\left(X=x|Y=c_k\\right)=P\\left(X^{\\left(1\\right)}=x^{\\left(1\\right)},\\cdots,X^{\\left(n\\right)}=x^{\\left(n\\right)}|Y=c_k\\right), \\ k=1,2,\\cdots,K $$ 但是由于条 …",
    
    "date": "2020-09-05 22:01:42",
    "updated": "2020-09-05 22:01:42"
  }
  
  , 
  {
    "objectID": "1598972674",
    "permalink": "/post/pat%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%80/",
    "title": "PAT刷题记录一",
    
    "content": "\r前言\r开个新坑，作为从小生活在北方的hiter，一直很向往南方的大学，高考很失败的没去上zju，那就研究生努力吧。看了一下，zju要求的上机测试可以用PAT甲级的成绩抵，那就开个刷题记录的新坑，之后可能也记录一些自己夏令营的经历。 初步先用 $Java$，之后转 $Python$ 吧。先说这些\u0026hellip;\n1001 A+B Format\r题目\rCalculate $a+b$ and output the sum in standard format \u0026ndash; that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\nInput Specification\nEach input file contains one test case. Each case contains a pair of integers $a$ and $b$ where $-10^6\\le a,b\\le 10^6$​​ . The numbers are separated by a space.\nOutput Specification\nFor each test case, you should output the sum of $a$ and $b$ in one line. The sum must be written in the standard format.\nSample Input\n-1000000 9 Sample Output\n-999,991 题解\r采用转化为字符串循环输出的方式，首先判断是否为负数。再对转化为字符串的结果绝对值进行判断，最前面的几位是否可以够3位，单独输出，最后把\u0026quot;,\u0026ldquo;和其后的三位数字在一起输出，循环切片即可。\npublic class PAT1001 { public static void main(String[] args) { int a, b; Scanner sc = new Scanner(System.in); a = sc.nextInt(); b = sc.nextInt(); if (a + b \u0026lt; 0) { System.out.print(\u0026#34;-\u0026#34;); } String s = Integer.toString(Math.abs(a + b)); int i = s.length() % 3 == 0 ? 3 : s.length() % 3; System.out.print(s.substring(0, i)); for (; i \u0026lt; s.length(); i += 3) { System.out.print(\u0026#34;,\u0026#34; + s.substring(i, i + 3)); } } } 1002 A+B for Polynomials\r题目\rThis time, you are supposed to find $A+B$ where $A$ and $B$ are two polynomials.\nInput Specification\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: $$ K\\ N_1\\ a_{N_k}\\ N_2\\ a_{N_2}\\cdots N_K\\ a_{N_K} $$ where $K$ is the number of nonzero terms in the polynomial,​​ $N_i$ and $a_{N_i} \\left(i=1,2,\\cdots,K\\right)$are the exponents and coefficients, respectively. It is given that $1\\le K\\le 10$，$0\\le N_K \\cdots ",
    
    "date": "2020-09-01 15:04:34",
    "updated": "2020-09-01 15:04:34"
  }
  
  , 
  {
    "objectID": "1598886274",
    "permalink": "/post/k%E8%BF%91%E9%82%BB%E6%B3%95/",
    "title": "k近邻法",
    
    "content": "\r一、k近邻算法\rk近邻法(k-nearest neighbor, k-NN)是一种基本分类与回归方法，这里指的是分类问题中的k邻近法。k近邻法的输入为实例的特征向量，对应于特征空间里的点；输出为实例的类别，可以取多类。分类时，对于新的实例，根据其k个最邻近的训练实例的类别，通过多数表决等方式进行预测。因此，k邻近法不具有显式的学习过程，实际上是利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。 k近邻法的三要素：k值的选择、距离度量及分类决策规则。\n1.1 k近邻算法\rk近邻算法：给定一个训练数据集，对于新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分到这个类。\n算法 1 （k近邻法） 输入：训练数据集 $T=\\left\\{\\left(x_1,y_1\\right),\\left(x_2,y_2\\right),\\cdots,\\left(x_N,y_N\\right)\\right\\}$ ，其中，$x_i\\in \\mathcal{X}=\\mathbf{R}^{\\text{n}}$ 为实例的特征向量，$y_i\\in \\mathcal{Y}=\\left\\{c_1,c_2,\\cdots c_K\\right\\}$ 为实例的类别, $i=1,2,\\cdots, N$ ；实例特征向量 $x$； 输出：实例 $x$ 所属的类别 $y$。\n根据给定的距离度量，在训练集 $T$ 中找出与 $x$ 最邻近的 $k$ 个点，涵盖这 $k$ 个点的 $x$ 的邻域记为 $N_k\\left(x\\right)$； 在 $N_k\\left(x\\right)$ 中根据分类决策规则决定 $x$ 的类别 $y$ $$ y=\\arg \\underset{c_j}{\\max}\\sum_{x_i\\in N_k\\left( x \\right)}{I\\left( y_i=c_j \\right)},\\ i=1,2,\\cdots ,N\\ ;\\ j=1,2,\\cdots ,K $$ 式中的 $I$ 为指示函数，当 $y_i=c_j$ 时 $I$ 为1，否则 $I$ 为0. k近邻法的特殊情况是 $k=1$ 的情况，称为最邻近算法。对于输入的实例点 $x$，最邻近法将训练数据集中与 $x$ 最邻近点的类作为 $x$ 的类。\n需要注意的是，k近邻法没有显式的学习过 …",
    
    "date": "2020-08-31 15:04:34",
    "updated": "2020-08-31 15:04:34"
  }
  
  , 
  {
    "objectID": "1597528902",
    "permalink": "/post/%E5%86%B3%E7%AD%96%E6%A0%91/",
    "title": "决策树",
    
    "content": "\r一、决策树模型与学习\r决策树是一种基本的分类与回归方法。决策树整体是一个树型结构，在分类的问题中，表示基于特征对实例进行分类的过程。可以认为是if-then的规则集合，也可以认为是定义在特征空间与类空间上的条件概率分布。 优点是模型具有可读性，分类速度快。决策树学习通常分为三个步骤：特征选择、决策树生成和决策树的修剪。\n学习时，可以利用训练数据，根据损失函数的最小化原则建立决策树模型。 预测时，对新的数据，利用决策树模型进行分类。 1.1 决策树模型\r定义1 （决策树）\n分类决策树模型是一种描述对实例点进行分类的树型结构。由结点(node)和有向边(directed edge)组成。结点有两种类型：内部结点(internal node)和叶结点(leaf node)。内部结点表示一个特征或属性，叶节点表示一个类。 利用决策树分类，从根节点开始，对某一特征进行测试，根据分类结果，将其分配到其子节点；如此递归进行测试并分配，直到叶节点，最后将实例分配到叶节点的类中。图1-1是一个决策树的示意图，圆表示内部节点，方框表示叶节点。\n图1-1 决策树模型 1.2 决策树与if-then规则\r由决策树的根节点到叶节点的每一条路径构建一条规则；路径上的内部节点的特征对应着规则的条件，而叶节点的类对应着规则的结论。决策树的路径或其对应的if-then规则结合具有一个重要的性质：互斥且完备。即，每一个实例都被一条路径或规则覆盖，而且只被一条路径或规则覆盖。\n1.3 决策树与条件概率分布\r决策树还表示为定义在给定的特征条件下的类的条件概率分布。这些条件概率分布定义在特征空间的一个划分上。决策树将特征空间划分为互不相交的单元(cell)，并在单元上定义了一个类的概率分布。决策树的一条路径对应了划分中的一个单元。 假设 $X$ 为表示特征的随机变量，$Y$ 为表示类的随机变量，那么这个条件概率分布可以表示为 $P\\left(Y|X\\right)$。$X$ 的取值与给定的划分下单元的集合，$Y$ 取值于类的集合。各叶节点上的条件概率往往偏向某一个类的概率较大，决策树在分类时会将该实例分配到条件概率较大的那一类去。 图1-2表示了一种特征空间的划分与与之对应的决策树。\n图1-2 决策树对应于条件概率分布 1.4 决策树学习\r假定给定训练数据集 $$ D=\\left\\{ \\left( …",
    
    "date": "2020-08-15 22:01:42",
    "updated": "2020-08-15 22:01:42"
  }
  
  , 
  {
    "objectID": "1597010502",
    "permalink": "/post/%E6%84%9F%E7%9F%A5%E6%9C%BA/",
    "title": "感知机",
    
    "content": "\r一、基本形式\r感知机是一种线性二分类模型，输入为实例的特征向量，输出为实例的判别，取 $+1,\\ -1$ 二值。实际上感知机将输入空间（特征空间）中的实例划分为正负两类的分离超平面。 导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。\n1. 感知机模型： 假设输入空间（特征空间）是 $\\mathcal{X}\\in \\mathbf{R}^{\\text{n}}$ ，输出空间是 $\\mathcal{Y}=\\left \\{ +1,-1\\right \\}$ 。输入 $\\mathcal{x}\\in \\mathcal{X}$ 表示实例的特征向量，对应与输入空间的点；输出 $\\mathcal{y}\\in \\mathcal{Y}$ 表示实例的类别。由输入空间到输出空间的如下函数 $$f\\left(x\\right)=\\text{sign}\\left(w\\cdot x+b\\right) $$ 称为感知机。其中 $w$ 和 $b$ 为感知机的模型参数，$w\\in \\mathbf{R}^{\\text{n}}$ 为权值(weight)或权值向量(weight vector)，$b\\in \\mathbf{R}$ 为偏置(bias)， $w\\cdot x$ 表示 $w$ 与 $x$ 的内积。sign是符号函数。\n2. 感知机的几何解释： 线性方程 $w\\cdot x+b=0$ 对应于特征空间 $\\mathbf{R}^{\\text{n}}$ 中的一个超平面S，其中w是超平面的法向量，b是超平面的截距。此超平面将特征空间划分为两部分，位于两部分的点被分为正负两类，超平面S又叫分离超平面，如图1-1。\n图1-1 感知机模型 二、感知机的学习策略\r感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确区分的分离超平面。即确定模型参数 $w,b$ 。\n2.1 损失函数\r感知机的损失函数选择：误分类点到超平面S的总距离。对于输入空间 $\\mathbf{R}^{\\text{n}}$ 中的任意一点 $x_0$ 到超平面S的距离: $$\\frac{1}{\\lVert w \\rVert}\\left| w\\cdot x_0+b \\right| $$ ，其中 $\\lVert w\\rVert$ 是 $w$ 的 $L_2$ 范数。 补：$L_2$ 范数: $\\lVert w …",
    
    "date": "2020-08-09 22:01:42",
    "updated": "2020-08-09 22:01:42"
  }
  
  , 
  {
    "objectID": "1596483863",
    "permalink": "/post/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/",
    "title": "模型评估与选择",
    
    "content": "\r一、经验误差与过拟合\r1.1 一些概念\r错误率：分类错误的样本数占样本总数的比例。如果在m个样本中有a个样本分类错误，则错误率为$E=\\left. a \\middle/ m \\right.$ ；相应的，$1-\\left. a\\middle/ m \\right.$ 称为“精度”。\n误差：学习器的实际预测输出与样本的真实输出之间的差异；学习器在训练集上的误差称为“训练误差”或“经验误差”；在新样本上的误差称为“泛化误差”。\n1.2 过拟合与欠拟合\r1.2.1 过拟合(overfitting)与欠拟合(underfitting)\r不用晦涩难懂的定义了，通俗解释一下。为了希望得到在新样本上表现很好的学习器，应该从训练样本中尽可能的学习适用于所有潜在样本的“普遍规律”。当把训练样本学得“太好了”的时候，很可能把训练样本自身的一些特点当做了所有潜在样本都会具有的性质，这样会导致泛化性能下降，这就是“过拟合”。 欠拟合正好相反，即训练样本的一般性质尚未学好。\n1.2.2 解决办法\r欠拟合解决办法\n在决策树学习中扩展分支 在神经网络中增加训练轮数 过拟合问题 其实过拟合无法完全消除，只可进行“缓解”。因为机器学习面临的问题通常是NP难的问题，有效的学习算法必然是在多项式时间内运行完成。如果可以彻底避免过拟合，则通过经验误差最小化即可得到最优解，这就意味着构造性的证明了$P = NP$。因此，只要相信$P \\ne NP$ ，过拟合就无法避免。\n二、评估方法\r需要选择“测试集”来测试学习器对新样本的判别能力，以测试集上的“测试误差”作为泛化误差的近似。通常假设测试样本是从样本的真实分布中独立同分布采样而得。但是，测试集应该尽可能与训练集互斥，让测试样本尽量不在训练集中出现、未在训练过程中使用过。 为了对数据集D做适当处理，得到训练集S和测试集T。下面介绍几种常见方法。\n2.1 留出法\r“留出法”(hold-out)直接将数据集D划分为两个互斥的集合，其中一个作为训练集S，一个作为测试集T，即$D=S \\cup T$ , $S \\cap T=\\varnothing$，在S上训练模型，用T评估测试误差，作为对泛化误差的估计。\n注意要点：\n训练集/测试集的划分要尽可能保持数据分布的一致性，避免因为数据划分而引入的额外偏差对最终结果产生影响。例如可以采取“分层抽样”等一系列保留类别比例的抽样 …",
    
    "date": "2020-08-03 19:44:23",
    "updated": "2020-08-03 19:44:23"
  }
  
  , 
  {
    "objectID": "1596189577",
    "permalink": "/post/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/",
    "title": "监督学习与无监督学习",
    
    "content": "\r一、前言\r机器学习的算法有很多种，学习算法中主要的两种类型是监督学习和无监督学习。简单来说，监督学习就是教计算机如何完成任务，无监督学习使让计算机自行学习完成。 简言之，机器学习就是让机器从大量的数据集中学习，进而得到一个更加符合现实规律的模型，通过对模型的使用使得机器比以往表现的更好。\n1.1 基本术语\r数据集(data set): 数据集中每条数据记录是关于一个时间或对象的描述，称为一个示例(instance)或样本(sample)。 属性(attribute)/特征(feature): 反映事件或对象在某方面的表现或性质的事项。 属性值(attribute value): 属性上的取值。 属性空间(attribute space)/样本空间(sample value): 属性张成的空间，类似于线性代数中一组线性无关的基底张成的线性空间。 特征向量(feature vector): 每条数据可以在样本空间中找到自己的坐标位置，空间中每个点对应的坐标向量即特征向量。 1.2 表示方法\r一般的，令$D=\\left\\{\\boldsymbol{x}_1,\\boldsymbol{x}_2,\\cdots,\\boldsymbol{x}_{\\boldsymbol{m}}\\right\\}$ 表示包含m个示例的数据集，每个示例有d个属性描述，则每个示例$\\boldsymbol{x}_{\\boldsymbol{i}}=\\left(x_{i1};x_{i2};\\cdots;x_{id}\\right)$ 是d维样本空间$\\mathcal X $中的一个向量，$x_{ij} $是$\\boldsymbol{x}_i$ 在第j个属性上的取值，d称为样本$\\boldsymbol{x}_i$ 的维数。\n1.3 何为学习\r从数据中学得模型的过程称为“学习”(learning)或“训练”(training)，通过执行某个学习算法完成此过程。训练过程中使用的数据称为“训练数据”(training data)，其中每个样本称为一个“训练样本”(training data)，训练样本组成的集合称为“训练集”(training set)。\n如果我们需要判断一个新的示例是好是坏，仅有示例数据是不够的，需要建立关于“预测”(prediction)的模型。对于有预测结果的新示例，关于结果的信息称之为“标 …",
    
    "date": "2020-07-31 09:59:37",
    "updated": "2020-07-31 09:59:37"
  }
  
  , 
  {
    "objectID": "1592069611",
    "permalink": "/post/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5/",
    "title": "volatile关键字到底是啥",
    
    "content": "\r软件构造笔记-volatile关键字到底是啥\r在老师讲课时，讲到synchronized关键字时，有些地方听的不是太清楚，在网上找资料的时候，还看到了另一个关键字volatile，看了好多篇博客，做了如下的总结。\n一、volatile关键字简介\rsynchronized关键字是阻塞式同步，在线程竞争激烈的时候会逐渐由偏向锁膨胀为重量级锁。而volatile是JVM提供的最轻量级的同步机制。内存模型JMM告诉我们各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。不过线程在工作内存中进行操作后将会何时写入主内存中，这个时机普通机制是没有规定的。 volatile一般用于修饰会被不同线程访问和修改的变量，而针对volatile修饰的变量给JVM给了规定：线程对volatile变量的修改会立刻被其他线程感知，即被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，保证了数据的可见性。\n二、volatile实现原理\r加入volatile关键字的代码的class字节码中会多出了一个lock前缀指令，lock指令相当于一个内存屏障，主要做了三件事：\n重排序时不能把后面的指令重排序到内存屏障之前的位置 将当前处理器缓存行的数据写回系统内存 这个写回内存的操作会使其他CPU里缓存的该内存地址的数据无效，即新写入的值对别的线程可见 经过这一波操作后，其他的线程发现自己工作内存中的缓存失效后，就会从内存中重新读取该变量数据，即保证了其他线程可以获取当前最新值。即可以说volatile实现了缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n三、示例\r图3-1 示例 3.1 对volatile的happens-before分析：\r线程1先执行writer方法，然后线程2执行reader方法。 我们由happens-before规则推知，2 happens-before 3 （volatile变量的写happens-before于任意后续对volatile变量的读） 由传递性可以得知1 happens-before 4  …",
    
    "date": "2020-06-13 17:33:31",
    "updated": "2020-06-13 17:33:31"
  }
  
  , 
  {
    "objectID": "1589645627",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/",
    "title": "软件构造-第六章-第二节-错误与异常处理",
    
    "content": "\r软件构造第六章 第二节 错误与异常处理\r一、JAVA中的错误和异常\r1.1 Throwable\rThrowable 类是 Java 语言中所有错误或异常的超类。 继承的类：extends Object。 实现的接口：implements Serializable。 直接已知子类：Error, Exception（直接已知子类：IOException、RuntimeException）。 图1-1 Throwable接口 1.2 Error\rError类描述很少发生的Java运行时系统内部的系统错误和资源耗尽情况（例如，VirtualMachineError，LinkageError）。 对于内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束 Error的类型： 用户输入错误 例如：用户要求连接到语法错误的URL，网络层会投诉。 设备错误 硬件并不总是做你想做的。 输出器被关闭 物理限制 磁盘可以填满 可能耗尽了可用内存 二、异常的处理\r2.1 异常按结构层次的分类\r运行时异常：由程序员处理不当造成，如空指针、数组越界、类型转换 其他异常：程序员无法完全控制的外在问题所导致的，通常为IOE异常，即找不到文件路径等 2.2 异常按处理机制角度的分类\r区分checked 和 unchecked：编译器将检查是否为所有的已检查异常提供了异常处理机制，比如说我们使用Class.forName()来查找给定的字符串的class对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。\n2.2.1 Checked exception：\r编译器可帮助检查你的程序是否已抛出或处理了可能的异常 异常的向上抛出机制进行处理，如果子类可能产生A异常，那么在父类中也必须throws A异常。可能导致的问题：代码效率低，耦合度过高。 checked exception是需要强制catch的异常，你在调用这个方法的时候，你如果不catch这个异常，那么编译器就会报错，比如说我们读写文件的时候会catch IOException，执行数据库操作会有SQLException等。 对checked Exception处理机制　抛出：声明是throws，抛出时throw　捕获（try/catch）：try出现异常，忽略后面代码直接进入catch；无异常不进入catch；若catch中没 …",
    
    "date": "2020-05-16 16:13:47",
    "updated": "2020-05-16 16:13:47"
  }
  
  , 
  {
    "objectID": "1589307664",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%81%A5%E5%A3%AE%E6%80%A7%E4%B8%8E%E6%AD%A3%E7%A1%AE%E6%80%A7/",
    "title": "软件构造-第六章-第一节-健壮性与正确性",
    
    "content": "\r软件构造第六章 第一节 健壮性与正确性\r一、健壮性与正确性\r1.1 健壮性\r定义：系统在不 正常输入或不正常外部环境下仍能够表现正常的程度 面向健壮性编程： 处理未期望的行为和错误终止 即使终止执行，也要准确/无歧义的向用户展示全面的错误信息 错误信息有助于进行debug 健壮性原则： Paranoia (偏执狂)：总是假定用户恶意、假定自己的代码可能失败 把用户想象成白痴，可能输入任何东西（返回给用户的错误提示信息要详细、准确、无歧义） 对别人宽容点，对自己狠一点（对自己的代码要保守，对用户的行为要开放） 面向健壮性编程的原则： 封闭实现细节，限定用户的恶意行为 考虑极端情况，没有“不可能” 1.2 正确性\r含义：程序按照spec加以执行的能力，是最重要的质量指标！ 对比健壮性和正确性： 正确性：永不给用户错误的结果； 让开发者变得更容易：用户输入错误，直接结束（不满足precondition调用）。 健壮性：尽可能保持软件运行而不是总是退出； 让用户变得更容易：出错也可以容忍，程序内部已有容错机制。 正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance)； 对外的接口，倾向于健壮性；对内的实现，倾向于正确性。 Reliability（可靠性） = Robustness + correctness 二、如何评价健壮性与正确性\r2.1 外部观察角度\rMean time between failures (MTBF，平均失效间隔时间)：描述了可修复系统的两次故障之间的预期时间，而平均故障时间（MTTF）表示不可修复系统的预期故障时间。 2.2 内部观察角度\r残余缺陷率：每千行代码中遗留的bug的数量 ",
    
    "date": "2020-05-12 18:21:04",
    "updated": "2020-05-12 18:21:04"
  }
  
  , 
  {
    "objectID": "1589134864",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%AC%AC%E4%B8%89%E8%8A%82-%E9%9D%A2%E5%90%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E6%9E%84%E9%80%A0%E6%8A%80%E6%9C%AF/",
    "title": "软件构造-第五章-第三节-面向可维护性的构造技术",
    
    "content": "\r软件构造第五章 第三节 面向可维护性的构造技术\r一、基于状态的构造技术\r基于状态编程 使用有限状态机来定义程序的行为、使用状态来控制程序的执行 根据当前状态，决定下一步要执行什么操作、执行操作之后要转移到什么新的状态 1.1 基于自动机的编程\r定义： 基于自动机的编程是一种编程范例，其中该程序或程序的一部分被认为是有限状态机（FSM）或任何其他形式自动机的模型。 将程序视为有限自动机。 每个自动机一次只能执行一个“步骤”，并且程序的执行分为多个步骤。 这些步骤通过更改代表“状态”的变量的值相互通信。 程序的控制流程由该变量的值确定。 应用程序设计方法应类似于控制系统（自动机系统）的设计。 核心思想： 将程序视为是一个有限状态自动机，侧重于对“状态”及“状态转换”的抽象和编程 执行步骤： 程序执行的时间段明显分为自动机的各个步骤。 程序的执行被分解为一组自动执行的步骤。 每个步骤实际上是一个代码段的执行（所有步骤相同），该代码段具有单个入口点。 这样的部分可以是函数或其他例程，也可以只是循环体。 步骤之间的任何通信都只能通过显式记录的名为状态的变量集进行。 各步骤之间的通讯通过“状态变量”进行 在任何两个步骤之间，程序都不能具有其状态的隐式组件，例如局部（堆栈）变量的值，返回地址，当前指令指针等。 在进入自动机步骤的任何两个时刻获取的整个程序的状态只能在被视为自动机状态的变量值上有所不同。 使用方法： 程序执行就可看作是各自动步骤的不断循环 使用枚举类型enum定义状态 使用二维数组定义状态转换表 1.2 状态模式(State Pattern)\r意图： 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决： 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用： 代码中包含大量与对象状态有关的条件语句。 如何解决 将各种具体的状态类抽象出来。 关键代码： 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if\u0026amp;hellip;else 等条件选择语句。 应用实例： 打篮球的时候运动员可以有正常状 …",
    
    "date": "2020-05-10 18:21:04",
    "updated": "2020-05-10 18:21:04"
  }
  
  , 
  {
    "objectID": "1588843233",
    "permalink": "/post/%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
    "title": "何为线程池",
    
    "content": "\r软件构造笔记-何为线程池\r一、什么是线程池\r线程池，顾名思义就是装线程的池子。其用途是为了帮我们重复管理线程，避免创建大量的线程增加开销，提高响应速度。\n二、为什么要使用线程池\r规格严格的哈工大学生，不会希望别人看到我们的代码就开始吐槽，new Thread().start()会让代码看起来混乱臃肿，并且不好管理和维护，那么就需要用到线程池。 在编程中经常会使用线程来异步处理任务，但是每个线程的创建和销毁都需要一定的开销。如果每次执行一个任务都需要开一个新线程去执行，则这些线程的创建和销毁将消耗大量的资源；并且线程都是“各自为政”的，很难对其进行控制，更何况有一堆的线程在执行。线程池为我们做的，就是线程创建之后为我们保留，当我们需要的时候直接拿来用，省去了重复创建销毁的过程。\n三、线程池的处理逻辑\r3.1 线程池ThreadPoolExecutor构造函数\r图3-1 ThreadPoolExecutor构造函数 简单介绍一下各个参数的用途\ncorePoolSize -\u0026amp;gt; 该线程池中核心线程数最大值 核心线程：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会一直存在于线程池中（即使这个线程啥都不干），有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。\nmaximumPoolSize -\u0026amp;gt; 该线程池中线程总数最大值 线程总数=核心线程数+非核心线程数 非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程\nkeepAliveTime -\u0026amp;gt; 非核心线程闲置超时时长 这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。\nTimeUnit -\u0026amp;gt; keepAliveTime的单位 TimeUnit是一个枚举类型，其包括: NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天\nBlockingQueue workQueue -\u0026amp;gt; 线程池中的任务队列 默认情况下，任务进 …",
    
    "date": "2020-05-07 09:20:33",
    "updated": "2020-05-07 09:20:33"
  }
  
  , 
  {
    "objectID": "1588799610",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E9%9D%A2%E5%90%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
    "title": "软件构造-第五章-第二节-面向可维护性的设计模式",
    
    "content": "\r软件构造第五章 第二节 面向可维护性的设计模式\r一、创造性模式\r1.1 工厂模式(Factory Pattern)\r定义： 工厂方法模式也被称为虚拟构造器。当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 意图： 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 主要解决： 主要解决接口选择的问题。 应用实例： 需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 优点： 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。 满足OCP（Open-Closed Principle）： 对扩展的开放，对修改已有代码的封闭。 模式： 图1-1 工厂模式 示例： 图1-2 工厂模式构建示例 图1-3 客户端调用该工厂方法 1.2 抽象工厂模式(Abstract Factory)\r定义： 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 方法： 提供接口以创建一组相关/相互依赖的对象，但不需要指明其具体类。 用途： 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品时使用。例： ①当一个UI，包含多个窗口控件，这些控件在不同的OS中实现不同。 ②当一个仓库类，要控制多个设备，这些设备的制造商各有不同，控制接口有差异。 优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点： 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 示例： 图1-4 抽象工厂示例 二、结构化模 …",
    
    "date": "2020-05-06 21:13:30",
    "updated": "2020-05-06 21:13:30"
  }
  
  , 
  {
    "objectID": "1588088760",
    "permalink": "/post/%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/",
    "title": "不能使用泛型的几种情况",
    
    "content": "\r软件构造笔记-Java 中不能使用泛型的几种情况\r一、前言\rJava 1.5 引入了泛型来保证类型安全，防止在运行时发生类型转换异常，让类型参数化，提高了代码的可读性和重用率。但是有些情况下泛型也是不允许使用的，总结一下编码中不能使用泛型的一些场景。\n二、基本类型无法直接使用泛型\r以下写法是错误的：\n基本类型是不能够作为泛型类型的,需要使用它们对应的包装类。 三、泛型类型无法被直接实例化\r泛型类型可以理解为一个抽象类型，只是代表了类型的抽象，因此不能直接实例化它，下面的做法也是错误的：\n四、泛型无法作为静态变量类型\rJava 中的静态类型随着类加载而实例化，此时泛型的具体类型并没有声明。同时因为静态变量作为所有对象的共享变量，只有类实例化或者方法调用时才能确定其类型。如果是泛型类型将无法确定其类型。同样在类上声明的泛型也无法作为返回值类型出现在类的静态方法中，下面的写法也是错误的：\n五、无法进行 instanceof 判断\rJava 中的泛型是伪泛型，在编译期会被擦除，运行的字节码中不存在泛型，所以下面的判断条件无法进行：\n但是泛型的无界通配符 \u003c?\u003e 可以进行 instanceof 判断，你仔细想想为什么。\n六、无法创建参数化类型的数组\r首先下面这种写法是对的：\n但是加上了泛型就编译不通过了： 七、不能直接或者间接扩展Throwable\r下面的两种写法将引发编译错误：\n如果成立将出现：\n如何才能对异常进行具体的处理，这显然不便于精确的异常处理逻辑。但是可以抛出一个 不确定的异常，但是同样不能在静态方法中使用类声明的泛型：\n八、泛型擦除后相同参数签名的方法不能重载\r由于泛型擦除的原因，以下的不视为方法的重载且无法编译 ：\n",
    
    "date": "2020-04-28 15:46:00",
    "updated": "2020-04-28 15:46:00"
  }
  
  , 
  {
    "objectID": "1587747201",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E5%BA%A6%E9%87%8F%E4%B8%8E%E6%9E%84%E9%80%A0%E5%8E%9F%E5%88%99/",
    "title": "软件构造-第五章-第一节-可维护性的度量与构造原则",
    
    "content": "\r软件构造第五章 第一节 可维护性的度量与构造原则\r一、软件的维护和演化\r定义： 软件可维护性是指软件产品被修改的能力，修改包括纠正、改进或软件对环境、需求和功能规格说明变化的适应。简而言之，软件维护：修复错误、改善性能。 类型： 纠错性（25%） 适应性（25%） 完善性（50%） 预防性（4%） 演化： 软件演化是一个程序不断调节以满足新的软件需求过程。 演化的规律： 软件质量下降，延续软件生命 软件维护和演化的目标： 提高软件的适应性 延续软件生命 意义： 软件维护不仅仅是运维工程师的工作，而是从设计和开发阶段就开始了 在设计与开发阶段就要考虑将来的可维护性 ，设计方案需要“easy to change” 基于可维护性建设的例子： 模块化 OO设计原则 OO设计模式 基于状态的构造技术 表驱动的构造技术 基于语法的构造技术 二、可维护性的常见度量指标\r可维护性： 可轻松修改软件系统或组件，以纠正故障，提高性能或其他属性，或适应变化的环境。 除此之外，可维护性还有其他许多别名：可扩展性（Extensibility）、灵活性（Flexibility）、可适应性（Adaptability）、可管理性（Manageability）、支持性（Supportability）。总之，有好的可维护性就意味着容易改变，容易扩展。 软件可维护性的五个子特性： 易分析性。软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。 易改变性。软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。如果软件由最终用户修改，那么易改变性可能会影响易操作性。 稳定性。软件产品避免由于软件修改而造成意外结果的能力。 易测试性。软件产品使已修改软件能被确认的能力。 维护性的依从性。软件产品遵循与维护性相关的标准或约定的能力。 一些常用的可维护性度量标准： 圈复杂度（CyclomaticComplexity）：度量代码的结构复杂度。 代码行数（Lines of Code）：指示代码中的大致行数。 Halstead Volume：基于源代码中（不同）运算符和操作数的数量的合成度量。 可维护性指数（MI）：计算介于0和100之间的索引值，表示维护代码的相对容易性。 高价值意味着更好的可维护性。 继承的层次数：表示扩展到类层次结构的根的类定义的数量。 等级越深，就越难理解特定方法和字段在 …",
    
    "date": "2020-04-24 16:53:21",
    "updated": "2020-04-24 16:53:21"
  }
  
  , 
  {
    "objectID": "1587389652",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%AC%E4%B8%89%E8%8A%82-%E9%9D%A2%E5%90%91%E5%A4%8D%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
    "title": "软件构造-第四章-第三节-面向复用的设计模式",
    
    "content": "\r软件构造第四章 第三节 面向复用的设计模式\r一、结构型模式：Structural patterns\r1.1 适配器模式(Adapter)\r目的：将某个类/接口转换为用户期望的其他形式。 含义：适配器模式是作为两个互不相容的接口的桥梁，将某个类/接口转换为client期望的其他形式。适配器模式使得原本由于接口不兼容而不能一起工作的的那些类/接口可以一起工作。 用途：主要解决在软件系统中，需要将现存的类放到新的环境中，而环境要求的接口是现对象不能满足的。 实现方法：通过增加一个新的接口，将已存在的子类封装起来，client直接面向接口编程，从来隐藏了具体子类。适配器继承或依赖已有的对象，实现想要的目标接口。 对象：将旧组件重用到新系统（也称为“包装器”）。 模型： 图1-1 适配器模式模型 例：问题描述： LegacyRectangle是已有的类（需要传入矩形的一个顶点、长和宽），但是与client要求的接口不一致（需要给出对角线两个顶点坐标），我们此时建立一个新的接口Shape以供客户端调用，用户通过Shape接口传入两个点的坐标。Rectangle作为Adapter，实现该抽象接口，通过具体的方法实现适配。 在不适用适配器时：会发生委派不相容。 图1-2 LegacyRectangle类与Client类 图1-3 Shape接口 1.2 装饰器模式(Decorator)\r含义： 装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，它是作为一个现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保证类方法签名完整性的前提下，提供额外的功能。 装饰模式是继承的一个代替模式，装饰模式可以动态地给一个对象添加一些额外的职能。就增加功能来说，装饰器模式比生成子类更为灵活。 主要解决： 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 实现方法： 将具体功能职责划分，对每一个特性构造子类，通过委派机制增加到对象上。 用途： 为对象增加不同侧面的特性。 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点： 多层装饰比较复杂，客户端需要一个具有多特性的object，需要一层一层的装饰来实现 模型： 图1-4 装饰 …",
    
    "date": "2020-04-20 13:34:12",
    "updated": "2020-04-20 13:34:12"
  }
  
  , 
  {
    "objectID": "1587075882",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E9%9D%A2%E5%90%91%E5%A4%8D%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%8A%80%E6%9C%AF/",
    "title": "软件构造-第四章-第二节-面向复用的软件构造技术",
    
    "content": "\r软件构造第四章 第二节 面向复用的软件构造技术\r一、设计可复用的类\r1.1 行为子类型和LSP原则\r行为子类型 子类型多态（ Subtype polymorphism）：客户端可用统一的方式处理不同类型的对象 。 举例： 图1-1 子类型多态 在可以使用a的场景，都可以用c1和c2代替而不会有任何问题。 使用注意事项：\n在java的静态类型检查之中，编译器强调了几条规则： 子类型可以增加方法，但不可删 子类型需要实现抽象类型中的所有未实现方法 子类型中重写的方法必须有相同或子类型的返回值 子类型中重写的方法必须使用同样类型的参数 子类型中重写的方法不能抛出额外的异常 行为子结构也适用于指定的方法： 更强的不变量 更弱的前置条件 更强的后置条件 例：\n图1-2 例一 子类满足相同的不变量（同时附加了一个） 重写的方法有相同的前置条件和后置条件 故该结构满足LSP 图1-3 例二 子类满足相同的不变量（同时附加了一个） 重写的方法 start 的前置条件更弱 重写的方法 brake 的后置条件更强 故该结构满足LSP 图1-4 例三 子类型前置条件更强 故该结构不满足LSP 1.2 协变与逆变\r协变与逆变综述\n如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，A≤B表示A是由B派生出来的子类）： f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立； f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立； f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。 协变\n父类型-\u0026amp;gt;子类型：越来越具体(specific)。 在LSP中，返回值和异常的类型：不变或变得更具体 。 例： 图1-5 协变 逆变(Contra-variance)： 父类型-\u0026amp;gt;子类型：越来越抽象。 参数类型：要相反的变化，不变或越来越抽象。 但这在Java中是不允许的，因为它会使重载规则复杂化。 例： 图1-6 逆变 总结： 图1-7 协变与逆变总结 t\u0026amp;rsquo;是t的子类型，T\u0026amp;rsquo;是T的子类型； 1.子类型（属性、方法）关系； 2.不变性，重写方法； 3.协变，方法返回值变具体； 4.逆变，方法参数变抽象； 5.协变，参数变的更具体， …",
    
    "date": "2020-04-16 22:24:42",
    "updated": "2020-04-16 22:24:42"
  }
  
  , 
  {
    "objectID": "1586897682",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E7%9A%84%E5%BA%A6%E9%87%8F%E5%BD%A2%E6%80%81%E4%B8%8E%E5%A4%96%E9%83%A8%E8%A1%A8%E7%8E%B0/",
    "title": "软件构造-第四章-第一节-可复用性的度量、形态与外部表现",
    
    "content": "\r软件构造第四章 第一节 可复用性的度量、形态与外部表现\r一、什么是软件复用\r1.1 软件复用\r软件复用是使用现有软件组件实施或更新软件系统的过程。\n软件复用的两个观点：\n面向复用编程(programming for reuse)：开发出可复用的软件 开发成本高于一般软件的成本：要有足够高的适应性 性能差些： 针对更普适场景，缺少足够的针对性 基于复用编程(programming with reuse)：利用已有的可复用软件搭建应用系统 可复用软件库，对其进行有效的管理 往往无法拿来就用，需要适配 为什么需要复用：\n复用降低成本和开发时间 复用的代码经过充分测试，可靠、稳定 产出标准化，在不同应用中保持一致 软件复用的代价：\n软件可复用的部分需要设计在如下的标准上：明确的定义、开放的方法、简洁的交互规范、可理解的文档，并着眼于未来。 不仅program for reuse代价高，program with reuse代价也高 1.2 代码复用的类型：\r白盒复用：源代码可见，可修改和扩展\n含义：复制已有代码到正在开发的系统，进行修改 优点：可订制化程度高 缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解 黑盒复用：源代码不可见，不能修改\n含义：只能通过过API接口来使用，无法修改代码 优点：清晰、简单 缺点：适用性差 高复用性的软件应具有如下特性：\n小、简单 与标准兼容 灵活可变 可扩展 泛型、参数化 模块化 变化的局部性 稳定 丰富的文档和帮助 举例说明：JDK中可复用的库和API\n二、可复用实现的级别\r2.1 源代码级别的复用\r相关研究：如何从互联网上快速找到需要的代码片段？ 反向研究：如何从源代码中检测出克隆代码(clone code)？ 我们可以在如github, grepcode, searchcode等网站上搜索代码，实现复用。 2.2 模块级别的复用：类、抽象类、接口\r复用类：\n源码并非是必要的，可能只需要类文件或jar 只需要将这个类加入到类路径 可以使用工具javap获得一个类的public方法 复用类的注意事项： 文档十分重要 压缩会有助于复用 管理更少的代码 版本兼容性 需要和类相关的包 复用类的方法：继承和委派\n继承（Inheritance）： 类扩展了现有类的属性/行为； 另外，Override父类中所有方法； 通常需要在实施之前设计 …",
    
    "date": "2020-04-14 20:54:42",
    "updated": "2020-04-14 20:54:42"
  }
  
  , 
  {
    "objectID": "1586363305",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%AC%E4%BA%94%E8%8A%82-adt%E5%92%8Coop%E4%B8%AD%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7/",
    "title": "软件构造-第三章-第五节-ADT和OOP中的“等价性”",
    
    "content": "\r软件构造第三章 第五节 ADT和OOP中的“等价性”\r一、等价性equals() 和 ==\r1.1 等价关系\r等价关系是指对于关系E ⊆ T x T ，满足：\n自反性: x.equals(x)必须返回true 对称性: x.equals(y)与y.equals(x)的返回值必须相等。 传递性: x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。 从使用者/外部的角度去观察：\n我们说两个对象相等，当且仅当使用者无法观察到它们之间有不同，即每一个观察总会都会得到相同的结果。例如对于两个集合对象 {1,2} 和 {2,1}，我们就无法观察到不同： |{1,2}| = 2, |{2,1}| = 2 1 ∈ {1,2} is true, 1 ∈ {2,1} is true 2 ∈ {1,2} is true, 2 ∈ {2,1} is true 3 ∈ {1,2} is false, 3 ∈ {2,1} is false 1.2 ==与equals()方法\r==是引用等价性\n比较的是索引。更准确的说，它测试的是指向相等（referential equality）。如果两个索引指向同一块存储区域，那它们就是==的。对于之前提到过的快照图来说，==就意味着它们的箭头指向同一个对象。 equals()是对象等价性\nequals()操作比较的是对象的内容，换句话说，它测试的是对象值相等（object equality）。e在每一个ADT中，quals操作必须合理定义。 在自定义ADT时，需要重写Object的equals()方法，因为在Object中实现的缺省equals()是在判断引用等价性，如图所示。 当重写equals()方法时，应使用@Override注释。Java编译器将检查超类中是否确实存在具有相同签名的方法，如果在签名中犯了错误，则会给出一个编译器错误。 图1-1 Object类中的equals()方法 1.3 instanceof\rinstanceof运算符\ninstanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。 使用instanceof是动态检查，而非静态检查 不要在父类型中使用instanceof检查子类型。 使用注意 …",
    
    "date": "2020-04-08 16:28:25",
    "updated": "2020-04-08 16:28:25"
  }
  
  , 
  {
    "objectID": "1586272018",
    "permalink": "/post/java-%E4%B8%AD%E7%9A%84-comparator-%E5%92%8C-comparable/",
    "title": "Java 中的 Comparator 和 Comparable",
    
    "content": "\r软件构造笔记-Java 中的 Comparator 和 Comparable\r一、 前言\r最近看到了集合排序（基于 Java 8），学到了一种基于Stream的排序，排序可以这么写：\n这里排序用到了一个关键接口 java.util.Comparator。排序比较作为业务中经常出现的需求，我们有必要研究一下这个接口。\n二、 Comparator 概念\rComparator 是一个函数式接口。它经常用于没有天然排序的集合进行排序，如 Collections.sort 或 Arrays.sort。或者对于某些有序数据结构的排序规则进行声明，如 TreeSet 、TreeMap 。也就是该接口主要用来进行集合排序。\n三、Comparator 中的方法\rComparator 作为一个函数式接口只有一个抽象方法,但是它有很多的默认方法。\n3.1 compare 抽象方法\r作为Comparator 唯一的抽象方法，int compare(T o1,T o2) 比较两个参数的大小， 返回负整数，零，正整数 ，分别代表 o1 \u0026amp;lt; o2、o1=o2、o1 \u0026amp;gt; o2，通常分别返回 -1、0 或 1。伪表达式：\n// 输入两个同类型的对象 ，输出一个比较结果的int数字 (x1,x2)-\u0026amp;gt; int 实现该方法一定要注意以下事项：\n必须保证compare(x,y) 和compare(y,x) 的值的和必须为 0 。 必须保证比较的顺序关系是可传递的，如果compare(x,y)\u0026amp;gt;0 而且compare(y,z)\u0026amp;gt;0 则 compare(x,z)\u0026amp;gt;0。 如果存在 compare(x,y)=0，则对于 z 而言，存在 compare(x, z)==compare(y, z)。 然而并不严格要求(compare(x, y)==0) == (x.equals(y))。一般说来，任何违背这个条件的 Comparator 实现都应该明确指出这一事实情况。\n3.2 comparing 系列方法\r从 Java 8 开始，Comparator 提供了一系列的静态方法，并通过函数式的风格赋予 Comparator 更加强大和方便的功能，暂且称它们为 comparing系列方法。\n该方法是该系列方法的基本方法。来分析一下该方法。它一共两个参数都是函数式接口。 …",
    
    "date": "2020-04-07 15:06:58",
    "updated": "2020-04-07 15:06:58"
  }
  
  , 
  {
    "objectID": "1585927949",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%AC%E5%9B%9B%E8%8A%82-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/",
    "title": "软件构造-第三章-第四节-面向对象编程",
    
    "content": "\r软件构造第三章 第四节 面向对象编程\r一、面向对象编程基本概念\r1.1 对象\r对象是类的一个实例，有状态和行为。 例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 概念：一个对象是一堆状态和行为的集合。 状态是包含在对象中的数据，在Java中，它们是对象的fields。 行为是对象支持的操作，在Java中，它们称为methods。 1.2 类\r类是一个模板，它描述一类对象的行为和状态。 每个对象都有一个类 类定义了属性类型（type）和行为实现（implementation） 简单地说，类的方法是它的应用程序编程接口（API）。 类成员变量(class variable)又叫静态变量；类方法(class method)又叫静态方法： 实例变量(instance variable)和实例方法(instance method)是不用static形容的实例和方法； 二者有以下的区别： 类方法是属于整个类，而不属于某个对象。 类方法只能访问类成员变量（方法），不能访问实例变量（方法），而实例方法可以访问类成员变量（方法）和实例变量（方法）。 类方法的调用可以通过类名.类方法和对象类方法，而实例方法只能通过对象实例方法访问。 类方法不能被覆盖，实例方法可以被覆盖。 当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址 当该类创建对象后，类中的实例方法才分配入口地址， 从而实例方法可以被类创建的任何对象调用执行。 类方法在该类被加载到内存时，就分配了相应的入口地址。 从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。 类方法的入口地址直到程序退出时才被取消。 注意： 当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。 也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。 总结： 类变量和类方法与类相关联，并且每个类都会出现一次。 使用它们不需要创建对象。 实例方法和变量会在每个类的实例中出现一次。 举例： 图1-1 实例方法与类方法 1.3 接口\r概念：接口在JAVA编程语言中是一个抽象类型，用于设计和表达ADT的语言机制，其是抽象方法的集合，接口通常以interface来声明。 一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口 …",
    
    "date": "2020-04-03 15:32:29",
    "updated": "2020-04-03 15:32:29"
  }
  
  , 
  {
    "objectID": "1585678406",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E5%9E%8B/",
    "title": "软件构造-第三章-第三节-抽象数据型",
    
    "content": "\r软件构造第三章 第三节 抽象数据型\r一、ADT及其四种类型\r1.1 ADT的基本概念\r抽象数据类型（Abstract Data Type，ADT）是是指一个数学模型以及定义在该模型上的一组操作；即包括数据数据元素，数据关系以及相关的操作。 ADT具有以下几个能表达抽象思想的词： 抽象化：用更简单、更高级的思想省略或隐藏低级细节。 模块化： 将系统划分为组件或模块，每个组件可以设计，实施，测试，推理和重用，与系统其余部分分开使用。 封装：围绕模块构建墙，以便模块负责自身的内部行为，并且系统其他部分的错误不会损坏其完整性。 信息隐藏： 从系统其余部分隐藏模块实现的细节，以便稍后可以更改这些细节，而无需更改系统的其他部分。 关注点分离： 一个功能只是单个模块的责任，而不跨越多个模块。 1.2 ADT的四种类型\r前置定义：mutable and immutable types 可变类型的对象：提供了可改变其内部数据的值的操作。Date 不变数据类型： 其操作不改变内部值，而是构造新的对象。String Creators（构造器）： 创建某个类型的新对象，⼀个创建者可能会接受⼀个对象作为参数，但是这个对象的类型不能是它创建对象对应的类型。可能实现为构造函数或静态函数。（通常称为工厂方法） t* -\u0026amp;gt; T 例：Integer.valueOf( ) Producers（生产器）： 通过接受同类型的对象创建新的对象。 T+ , t* -\u0026amp;gt; T 例：String.concat( ) Observers（观察器）： 获取抽象类型的对象然后返回一个不同类型的对象/值。 T+ , t* -\u0026amp;gt; t 例：List.size( ) ； Mutators（变值器）： 改变对象属性的方法 ， 变值器通常返回void，若为void，则必然意味着它改变了对象的某些内部状态；当然，也可能返回非空类型 T+ , t* -\u0026amp;gt; t || T || void 例：List.add( ) 解释：T是ADT本身；t是其他类型；+ 表示这个类型可能出现一次或多次；* 表示可能出现0次或多次。 1.3 示例：\r图1-1 immutable类型示例 图1-2 mutable类型示例 图1-3 方法类型 二、设计与测试ADT\r2.1 设计ADT\r设计好的ADT，靠“经验法则”，提供一组操作，设计其行 …",
    
    "date": "2020-03-31 18:13:26",
    "updated": "2020-03-31 18:13:26"
  }
  
  , 
  {
    "objectID": "1585399439",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%BD%AF%E4%BB%B6%E8%A7%84%E7%BA%A6/",
    "title": "软件构造-第三章-第二节-软件规约",
    
    "content": "\r软件构造第三章 第二节 软件规约\r一、方法\r1.1 参数及返回值\r参数 参数类型是否匹配，在静态类型检查阶段完成\n返回值 返回值类型是否匹配，也在静态类型检查阶段完成\n1.2 一个完整的方法\r图1-1 完整的方法 一个完整的方法包括规约spec和实现体implementation； \u0026amp;ldquo;方法\u0026amp;quot;是程序的积木，它可以被独立的开发、测试、复用； 使用“方法”的客户端，无需了解方法内部如何工作，这就是抽象的概念； 参数类型和返回值类型的检查都是在静态类型检查阶段完成的。 二、规约：程序间的“语言”\r2.1 规约的重要性\r为什么要设计规约\n很多bug来自于双方之间的误解；没有规约，那么不同开发者的理解就可能不同 代码惯例增加了软件包的可读性，使工程师们更快、更完整的理解软件 可以帮助程序员养成良好的编程习惯，提高代码质量 没有规约，难以定位错误 规约的好处\n规约起到了契约的作用。代表着程序与客户端之间达成的一致；客户端无需阅读调用函数的代码，只需理解spec即可。 精确的规约，有助于区分责任，给“供需双方”确定了责任，在调用的时候双方都要遵守。 规约的示例\n图2-1 java中Integer的add方法 规约可以隔离“变化”，无需通知客户端 规约也可以提高代码效率 规约扮演“防火墙”角色 图2-2 规约起“防火墙的作用” 标准规约 参考阿里Java开发手册之编程规约 2.3 行为等价性\r行为等价性就是站在客户端的角度考量两个方法是否可以互换； 根据规约判断是否行为等价注：规约与实现无关，规范无需讨论方法类的局部变量或方法类的私有字段。 2.4 规约的前置条件与后置条件\r一个方法的规约常由以下几个短句组成契约：如果前置条件满足了，后置条件必须满足。如果没有满足，将产生不确定的异常行为\n前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件。由关键字 requires 表示； 后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件。由关键字 effects 表示； 异常行为(Exceptional behavior) 规约前置条件与后置条件\n图2-3 规约前置条件与后置条件 Java中的规约 静态类型声明是一种规约，可据此进行静态类型检查。 方法前的注释也是一种规约，但需人工判定其是否满足。 参数 …",
    
    "date": "2020-03-28 12:43:59",
    "updated": "2020-03-28 12:43:59"
  }
  
  , 
  {
    "objectID": "1585049719",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/",
    "title": "软件构造-第三章-第一节-数据类型与类型检查",
    
    "content": "\r软件构造第三章 第一节 数据类型与类型检查\r一、数据类型\r1.1 类型和变量\r数据类型： 基本数据类型 int double long boolean double char 面向对象的数据类型 String BigInteger 对于Java，基本数据类型首字母小写，面向对象数据类型首字母大写。 基本数据类型直接在栈中存值，不存变量名；面向对象数据类型在堆中存储，运行时在堆中为其分配内存，不仅值，也存变量名。 图1-1 基本数据类型与面向对象的数据类型差异 二、静态检查、动态检查\r2.1 静态检查VS动态检查\rJava是一种静态类型的语言；所有变量的类型在编译的时候就已经知道了（程序还没有运行），所以编译器也可以测出每一个表达式的类型。在动态类型语言中（例如Python），这种类型检查是发生在程序运行的时候。 2.2 静态检查：关于“类型”的检查\r检查严格程度：静态检查\u0026amp;raquo;动态检查\u0026amp;raquo;无检查。\n在编译阶段发现错误，避免将错误带入到运行阶段，提高程序的正确性\\健壮性\n静态分析检查的类型\n语法错误，例如多余的标点符号或者错误的关键词。即使在动态类型的语言例如Python中也会做这种检查：如果你有一个多余的缩进，在运行之前就能发现它。 类名\\函数名错误，例如Math.sine(2) . (应该是 sin ) 参数数目错误，例如 Math.sin(30, 20) 参数的型错误 Math.sin(\u0026amp;ldquo;30\u0026amp;rdquo;) 返回值类型错误 ，例如⼀个声明返回 int 类型函数 return \u0026amp;ldquo;30” 2.3 动态检查：关于“值”的检查\rbug在运行中被发现。\n倾向于检查特定值才出发的错误 动态分析检查的类型： 非法的变量值。例如整型变量x、y，表达式x/y 只有在运行后y为0才会报错，否则就是正确的。 非法的返回值。例如最后得到的返回值无法用声明的类型来表明。 越界访问。例如在一个字符串中使用一个负数索引。 空指针，使用一个null 对象解引用。 三、Mutability \u0026amp;amp; Immutability\r改变一个变量：是将该变量指向另一个值得存储空间 改变一个变量的值：是将该变量当前指向的值的存储空间中写入一个新的值\n3.1 Immutability(不变性)\rfinal 变量能被显式地初始化并且只能初始化一次。不变数据类型， …",
    
    "date": "2020-03-24 11:35:19",
    "updated": "2020-03-24 11:35:19"
  }
  
  , 
  {
    "objectID": "1584826857",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%AC%E4%BA%8C%E8%8A%82-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E8%BF%87%E7%A8%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%B7%A5%E5%85%B7/",
    "title": "软件构造-第二章-第二节-软件构造的过程、系统和工具",
    
    "content": "\r软件构造第二章 第二节 软件构造的过程、系统和工具\r一、广义的软件构造过程\r1.1 编程(Programming)\r图1-1 常见软件构造过程 Construction languages\n用途上划分语言 Programming languages (e.g., C, C++, Java, Python) 编程语言 Modeling languages (e.g., UML) 建模语言 Configuration languages (e.g., XML) 配置语言 Build languages (e.g., XML) 构建语言 从形态上划分 Linguistic-based 基于语言学的构造语言 Mathematics-based (formal) 基于数学的形式化构造语言 Graphics-based (visual) 基于图形的可视化构造语言 Programming tools\n集成开发环境IDE IDE包括： Source code editor with intelligent code completion, code refactoring tool 源代码编辑器、智能代码补全工具、代码重构工具 File management tool 文件管理 Library management tool 库管理 Class browser, object browser, class hierarchy diagram 软件逻辑实体可视化 Graphical User Interface (GUI) builder 图形化用户界面构造器 Compiler, interpreter 编译器、解释器 Build automation tools 自动化build工具 Version control system 版本控制系统 Extensible by more external third-party tools 外部的第三方工具 Modeling languages 建模语言\n建模语言： 建模语言是可以用来在由一致的规则集定义的结构中表达信息或知识或系统的任何人工语言，目的是可视化，推理，验证和传达系统的设计。 UML语言: 图1-2 UML图 图1-3 UML图示例 Configuration languages 配置语言 配置文件配置程序的参数和初始设 …",
    
    "date": "2020-03-21 21:40:57",
    "updated": "2020-03-21 21:40:57"
  }
  
  , 
  {
    "objectID": "1584808936",
    "permalink": "/post/java%E5%9F%BA%E7%A1%80%E7%AF%87string-%E5%92%8C-stringbufferstringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB/",
    "title": "Java基础—String 和 StringBuffer、StringBuilder 的区别",
    
    "content": "\r软件构造笔记-Java基础—String 和 StringBuffer、StringBuilder 的区别\r一、三者简介\r1.1 String\rString 表示的就是 Java 中的字符串，日常用到的使用 \u0026quot;\u0026quot; 双引号包围的数都是字符串的实例。String 类其实是通过 char 数组来保存字符串的。下面是一个典型的字符串的声明 String s = \u0026ldquo;abc\u0026rdquo;; 上面创建了一个名为 abc 的字符串。 字符串是Immutable的，一旦创建出来就不会被修改\n1.2 StringBuffer\rStringBuffer对象代表一个可变的字符串序列，当一个 StringBuffer 被创建以后，通过 StringBuffer 的一系列方法可以实现字符串的拼接、截取等操作。一旦通过 StringBuffer 生成了最终想要的字符串后，就可以调用其 toString 方法来生成一个新的字符串。StringBuffer 是线程安全的。\n1.3 StringBuilder\rStringBuilder 其实是和 StringBuffer 几乎一样，只不过 StringBuilder 是非线程安全的。并且，为什么 + 号操作符使用 StringBuilder 作为拼接条件而不是使用 StringBuffer 呢？我猜测原因是加锁是一个比较耗时的操作，而加锁会影响性能，所以 String 底层使用 StringBuilder 作为字符串拼接。\n二、区别\r2.1 可变性\rString 不可变 翻阅String源码，可以发现有一核心的属性 private final char value[];final很好地说明了String的不可变型，只可读，不可改。 对String进行任何的修改操作，如substring，replace，都会先复制一份String副本进行修改，在复制回堆区，相当于重新创建了一个String对象，原来的引用指向新的String。所以，在数据量很大的情况下，要不断进行复制操作，很占内存，这时要避免使用String。 StringBuilder 与 StringBuffer 可变 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类 他们的构造函数执行时都会调用super()，调用父类的构造函数\nchar[] value 没有final修饰，说明它是一个可变对象，可以进行读和写操作。 线程安全性 要验证这点非常容易，只要打开源码 StringBuffer对方法加了同步锁或者对调用的方法加了synchronized同步锁，所以是线程安全的。String，StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n2.2 性能\r每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n三、使用总结\r操作少量的数据 =\u0026gt; String 单线程操作字符串缓冲区下操作大量数据 =\u0026gt; StringBuilder 多线程操作字符串缓冲区下操作大量数据 =\u0026gt; StringBuffer\n",
    
    "date": "2020-03-21 16:42:16",
    "updated": "2020-03-21 16:42:16"
  }
  
  , 
  {
    "objectID": "1584481257",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%AC%E4%B8%80%E8%8A%82-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/",
    "title": "软件构造-第二章-第一节-软件生命周期和版本控制",
    
    "content": "\r软件构造-第二章-第一节-软件生命周期和版本控制\r一、软件开发基本过程\r1.1 软件生命周期\r软件开发生命周期——从0到1 策划阶段：获取需求、制定计划 架构师：系统分析（业务领域，what）、软件设计（语言、架构，how） 编码实现、测试 维护直至消失 图1-1 软件开发生命周期 软件生命周期中的多版本——从1到n 运用版本控制技术实现迭代更新 图1-1 软件开发生命周期 二、传统软件开发过程模型\r2.1 软件开发过程\r两种典型过程 - Linear 线性过程 - Iterative 迭代过程(大致为线性过程加反馈) 典型开发模型 - Waterfall (Linear, non-iterative) 瀑布过程(线性，不迭代) - Incremental (non-iterative) 增量过程(不迭代) - V-Model (for verification and validation) V字模型(用于验证和确认) - Prototyping (iterative) 原型过程(迭代) - Spiral (iterative) 螺旋模型(迭代) 选择合适的过程模型的依据 - 用户参与程度有多大？即软件适应变化的能力 - 开发效率/管理复杂度 - 开发软件的质量\n2.2 瀑布模型\r瀑布模型： 瀑布模型将软件生存周期的各项活动规定为依固定顺序而连接的若干阶段工作。 特点： 瀑布模型规定了每一个阶段的输入，以及本阶段的工作成果，作为输出传入下一阶段；早期主流开发过程，适用于需求稳定的项目。 简述为： • 线性推进 • 阶段划分清楚 • 整体推进 • 无迭代 • 管理简单 • 无法适应需求增加/变化 优缺点： 优点：有设计前的规约和编码前的设计，易于管理； 缺点：应对变化时，成本十分高。 图2-1 瀑布模型开发过程 2.3 增量模型\r增量模型： 运用分治的思想，将需求分段，成为一系列增量产品，每个增量内部仍使用瀑布模型； 增量模型是瀑布模型的变形，拥有后者的全部优点，此外可以很快的迭代出第一版本。因此，选择最核心需求首先实现显得十分重要。 特点： • 线性推进 • 增量式（多个瀑布的串行） • 无迭代 • 比较容易适应需求的增加 图2-2 增量模型开发过程 2.4 V模型\rV模型： V模型表示可以视为瀑布模型的扩展的开发过程。\n特点： • 弯曲工艺步骤，而不是以线性方 …",
    
    "date": "2020-03-17 21:40:57",
    "updated": "2020-03-17 21:40:57"
  }
  
  , 
  {
    "objectID": "1584113288",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%AC%AC%E4%BA%94%E8%8A%82-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95%E4%BC%98%E5%85%88%E7%BC%96%E7%A8%8B/",
    "title": "软件构造-第六章-第五节-软件测试与测试优先编程",
    
    "content": "\r软件构造第六章 第五节 软件测试与测试优先编程\r一、测试和测试优先编程\r1.1 什么是测试\r测试提高软件质量的重要手段（但不是最重要的手段），执行程序或应用程序的过程，目的是发现错误（或其他缺陷），并验证软件产品是否适合使用。确认是否达到可用级别(用户需求)，它关注系统的某一侧面的质量特性，一般来说，这些属性表示正在测试的组件或系统的程度。\n1.2 测试的目标\r测试的目标与其他开发活动的目标背道而驰，目标是找出错误，再好的测试也无法证明系统里不存在错误\n好的测试特点：\n能发现错误 不冗余 具有最佳特性 既不复杂也不简单 1.3 测试的分类\r单元测试：针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试。 集成测试 系统测试 回归测试 验收测试 1.4 静态测试与动态测试\r静态测试 静态测试通常是隐式的，例如校对以及编程时工具/文本编辑器检查源代码结构或编译器（预编译器）检查语法和数据流，作为静态程序分析。 包括代码复查，总览和静态检查。 动态测试 动态测试描述了对动态行为的测试代码，实际上执行给定集合的编程代码测试用例。\n动态测试可能会在程序按顺序完成100％之前开始测试代码的特定部分并应用于离散函数或模块。 常使用存根、驱动程序或使用调试器。 测试与调试区别 测试的目的是发现是否存在错误。 调试的目的是识别错误，消除错误。 二、黑盒测试和白盒测试\r2.1 黑盒测试\r定义 对程序外部表现出来的行为的测试，用于检查代码的功能，不关心内部的实现。 黑盒测试用例构造标准 黑盒测试的测试用例围绕规约和要求，即应用程序应该做什么。检查程序是否符合规约。 要求用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。 构造测试用例的方法\n等价类划分 将被测函数的输入域划分为等价类，从等价类中导出测试用例 针对每个输入数据需要满足的约束条件，划分等价类（自反、传递、对称），等价类划分可有两种不同的情况：有效等价类和无效等价类。 等价类划分原理：基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可。 边界值分析 大量的错误发生在边界而不是中央。这是对等价划分方法的一个补充，将边界作为等价类之一进行考虑，通常边界值的左右也是需要进行考虑的。 边界值分析法是对输入输出的边界值进行测试一种黑盒测试方法，是对等价类分析法的补充。 方法：找 …",
    
    "date": "2020-03-13 15:28:08",
    "updated": "2020-03-13 15:28:08"
  }
  
  , 
  {
    "objectID": "1583681258",
    "permalink": "/post/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/",
    "title": "软件构造第一章总结",
    
    "content": "\r软件构造第一章总结\r一、软件构造多维度视图\r1.1 从三个维度看软件系统的构成\r按阶段划分：build-time（构造阶段）和run-time（运行阶段） 按动态划分：moment（时刻）和period（时期） 按层次划分：code（代码层面）和component（组件，文件层面） 图1-1 软件构造多维度视图 二、软件构造的阶段划分、各阶段的构造活动\r2.1. Build-time\r想法⇒\\Rightarrow⇒需求⇒\\Rightarrow⇒设计⇒\\Rightarrow⇒代码⇒\\Rightarrow⇒可安装并执行的包 Code-level view：代码的逻辑组织（函数、类、方法、接口······） Component-level view：代码的物理组织（文件、目录、包、程序库······） Moment view：特定时刻的软件形态 Period view：软件形态随时间的变化\n1. build-time; moment; code-level 三种相互关联的形式\n面向词法：半结构化源代码 面向词法：（AST抽象语法树）半结构化的源代码变成语法树（编译器能够处理） 面向词法：UML视图（通常是图形化或形式化的）\n图2-1 UML图 2. build-time; period; code-level Code churn（代码变化）\n3. build-time; moment; component-level 源代码如何组织成文件——通过类库 文件被压缩进package，逻辑上进入components（组件）and sub-systems（子系统）\n链接技术（动态 / 静态） Library\n操作系统提供的库 编程语言提供的库 第三方公司提供的库 自己编写的库 链接：编程时和build时，需告诉IDE和JVM在哪里寻找某些库。\n静态链接\n库被拷贝进入代码形成整体，执行的时候无需提供库文件。 静态链接发生在构造阶段。\n4. build-time; period; component-level SCI 配置项的更改 VCS 版本控制系统 各项软件实体随时间如何变化 软件随时间变化的版本 版本控制（通过Git，SVN等等）\n2.2 Run-time\r程序被载入目标机器，开始执行。\nCode-level view： …",
    
    "date": "2020-03-08 15:27:38",
    "updated": "2020-03-08 15:27:38"
  }
  
  , 
  {
    "objectID": "1583309505",
    "permalink": "/post/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/",
    "title": "算法设计与分析第二次作业",
    
    "content": "\r算法设计与分析第二次作业\r1. 证明或否证： $ f\\left( n \\right) +o\\left(f\\left( n \\right) \\right)=\\varTheta\\left(f\\left( n \\right) \\right) $\r证明： 对 $ \\forall c\u003e0 $, $\\exists\\, n_0\u003e0$, 对$\\forall \\,n\\ge n_0$, 有$0\\le o\\left(f\\left( n \\right) \\right)\\le cf\\left( n \\right)$, 则$f\\left( n \\right)\\le f\\left( n \\right)+o\\left( f\\left ( n \\right) \\right) \\le \\left( c+1 \\right) f\\left ( n \\right) $, 故有$ f\\left( n \\right) +o\\left(f\\left( n \\right) \\right)=\\varTheta\\left(f\\left( n \\right) \\right) $.\n2. 证明： $\\varTheta\\left(f\\left( x \\right) \\right) + O \\left(g\\left(x\\right)\\right) = O\\left( max\\{f\\left(x\\right), g\\left(x\\right) \\}\\right) $\r证明： 由定义可知$\\exists \\,c_1, c_2\u003e0$, $\\exists\\, x_0$, 对$\\forall \\,x\\ge x_0,\\,c_1f\\left( x \\right)\\le\\varTheta \\left (f\\left(x\\right)\\right)\\le c_2f\\left( x \\right), $且$\\exists\\, c_3 \u003e 0$, $\\exists \\,x_1, $ 对$\\forall\\, x\u003ex_1,$ $ 0\\le O\\left(g\\left(x\\right)\\right)\\le g\\left(x\\right). $ 故有, 对$\\forall\\,x\\ge max \\{ x_0, \\,x_1\\}$, $c_1f\\left(x\\right)\\le \\varTheta\\left(f\\left(x\\right)\\right)+O\\left(g\\left(x\\right)\\right)\\le c_2f\\left(x\\right)+cg\\left(x\\right)\\le \\left(c_2+c\\right)max\\{f\\left(x\\right)+g\\left(x\\right)\\}$ 故$\\varTheta\\left(f\\left( x \\right) \\right) + O \\left(g\\left(x\\right)\\right) = O\\left( max\\{f\\left(x\\right), g\\left(x\\right) \\}\\right)$\n3. 证明或给出反例： $\\varTheta\\left(f\\left(n\\right)\\right)\\cap o\\left(f\\left(n\\right)\\right) = \\varnothing $\r证明： 假设$\\exists\\,g\\left(n\\right)\\in\\varTheta\\left(f\\left(n\\right)\\right)\\cap o\\left(f\\left(n\\right)\\right)$, 则必有$g\\left(n\\right)\\in\\varTheta\\left(f\\left(n\\right)\\right)且g\\left(n\\right)\\in o\\left(f\\left(n\\right)\\right).$ 由定义得, 必有$\\exists \\,c_1,\\,c_2\u003e0,\\,n_0$, $对\\forall\\, n\\ge n_0, \\,c_1f\\left(n\\right)\\le g\\left(n\\right)\\le c_2f\\left(n\\right)$, $且对\\forall c\u003e0$, $\\exists n_1\u003e0$, $\\forall n\\ge n_0$, 有$0\\le g\\left(n\\right)\u003c cf\\left(n\\right)$, 易知二者矛盾, 固原假设不成立. 即：$\\varTheta\\left(f\\left(n\\right)\\right)\\cap o\\left(f\\left(n\\right)\\right) = \\varnothing $\n4. 证明：设k是任意常数正整数，则$log_kn$\r未完待续\u0026hellip;大概率鸽了。。。\n",
    
    "date": "2020-03-04 08:11:45",
    "updated": "2020-03-04 08:11:45"
  }
  
  , 
  {
    "objectID": "1583249377",
    "permalink": "/post/java%E5%9F%BA%E7%A1%80-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B%E4%B8%80%E7%9C%8Barraylist%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/",
    "title": "Java基础 | 从源码看一看ArrayList的几个常见方法",
    
    "content": "\r从源码看一看ArrayList的几个常见方法\r第一节 ArrayList简介\rArrayList是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List，RandomAccess[随机访问]，Cloneable[可克隆]，java.io.Serializable[序列化]这些接口。ArrayList继承了AbstractList，实现了List，提供了相关的添加、删除、修改、遍历等功能。 ArrayList实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，可以通过元素的序号快速获取元素对象，即快速随机访问。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 与Vector不同，ArrayList中的操作不是线程安全的。所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 第二节 增删查改源代码解析\r2.1 增加\rArrayList添加元素的操作，这里介绍两个方法 add(E object) 和 add(int index, E object) 。其他的方法，类似addAll(int index, Collection\u0026amp;lt;? extends E\u0026amp;gt; c)等，自行探索即可。\nadd(E object)方法 add(E object)方法的结果是在list末尾增添新元素，源码如图2-1所示。 图2-1 add(E object)方法源码 可以看到add()方法首先使私有属性modCount自增。然后调用私有方法add(E e, Object[] elementData, int s)，最后返回。add(E e, Object[] elementData, int s)方法首先检查List长度，若目前List长度等于size，则会调用grow()方法进行扩容。grow()方法如图2-2所示：\n图2-2 grow()方法 如果原有List不空， …",
    
    "date": "2020-03-03 15:29:37",
    "updated": "2020-03-03 15:29:37"
  }
  
]