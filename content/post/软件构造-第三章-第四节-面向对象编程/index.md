---
title: 软件构造-第三章-第四节-面向对象编程
date: 2020-04-03 15:32:29
draft: false
math: true
cover: images/featureimages/6.jpg
summary: 软件构造课程笔记
tags: [软件构造,Java]
categories: ["软件构造"]
---
软件构造第三章 第四节 面向对象编程
 ================
<!-- toc -->

 <!--more-->

# 一、面向对象编程基本概念

## 1.1 对象

1. 对象是类的一个实例，有状态和行为。
2. 例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
3. 概念：一个对象是一堆状态和行为的集合。
   - 状态是包含在对象中的数据，在Java中，它们是对象的fields。
   - 行为是对象支持的操作，在Java中，它们称为methods。

## 1.2 类

1. 类是一个模板，它描述一类对象的行为和状态。
2. 每个对象都有一个类
3. 类定义了属性类型（type）和行为实现（implementation）
4. 简单地说，类的方法是它的应用程序编程接口（API）。
5. 类成员变量(class variable)又叫静态变量；类方法(class method)又叫静态方法：
6. 实例变量(instance variable)和实例方法(instance method)是不用static形容的实例和方法；
7. 二者有以下的区别：
   - 类方法是属于整个类，而不属于某个对象。
   - 类方法只能访问类成员变量（方法），不能访问实例变量（方法），而实例方法可以访问类成员变量（方法）和实例变量（方法）。
   - 类方法的调用可以通过类名.类方法和对象类方法，而实例方法只能通过对象实例方法访问。
   - 类方法不能被覆盖，实例方法可以被覆盖。
   - 当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址 当该类创建对象后，类中的实例方法才分配入口地址， 从而实例方法可以被类创建的任何对象调用执行。
   - 类方法在该类被加载到内存时，就分配了相应的入口地址。 从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。 类方法的入口地址直到程序退出时才被取消。
8. 注意：
   - 当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。
   - 也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。
9. 总结：
   - 类变量和类方法与类相关联，并且每个类都会出现一次。 使用它们不需要创建对象。
   - 实例方法和变量会在每个类的实例中出现一次。
10. 举例：
<center>
<img src="https://img-blog.csdnimg.cn/20200411203959453.png" width="80%" height="35%">
</center>
<center>
图1-1 实例方法与类方法
</center>
<br>

## 1.3 接口

1. 概念：接口在JAVA编程语言中是一个抽象类型，用于设计和表达ADT的语言机制，其是抽象方法的集合，接口通常以interface来声明。
2. 一个类通过继承接口的方式，从而来继承接口的抽象方法。
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
3. 一个接口可以扩展其他接口，一个类可以实现多个接口；一个接口也可以有多重实现
4. 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
5. 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
<center>
<img src="https://img-blog.csdnimg.cn/20200411210144481.png" width="100%" height="100%">
</center>
<center>
图1-2 接口示例
</center>
<br>
<center>
<img src="https://img-blog.csdnimg.cn/20200411210149377.png" width="100%" height="35%">
</center>
<center>
图1-3 接口实现
</center>
<br>

6. client使用此ADT：
<center>
<img src="https://img-blog.csdnimg.cn/20200411211442923.png" width="100%" height="35%">
</center>
<center>
图1-4 client使用此ADT
</center>
<br>

&emsp;&emsp;但其中有问题，这么实现接口打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。 故而，客户端需要知道该接口的某个具体实现类的名字。因为Java中的接口不能包含构造函数，所以它们必须直接调用其中一个具体类的构造函数。该构造函数的规范不会出现在接口的任何地方，所以没有任何静态的保证，即不同的实现甚至会提供相同的构造函数。
&emsp;&emsp;在Java 8中，我们可以用valueof的静态工厂方法 代替构造器。
<center>
<img src="https://img-blog.csdnimg.cn/20200411211455858.png" width="100%" height="35%">
</center>
<center>
图1-5 valueof静态工厂方法
</center>
<br>

&emsp;&emsp;此时用户调用ADT不会破坏抽象边界。
<center>
<img src="https://img-blog.csdnimg.cn/20200411212602253.png
" width="100%" height="35%">
</center>
<center>
图1-6 调用MyString类
</center>
<br>

7. 总结：接口的好处
   - Safe from bugs
     - ADT是由其操作定义的，接口就是这样做的。
     - 当客户端使用接口类型时，静态检查确保他们只使用由接口定义的方法。
     - 如果实现类公开其他方法，或者更糟糕的是，具有可见的表示，客户端不会意外地看到或依赖它们。
     - 当我们有一个数据类型的多个实现时，接口提供方法签名的静态检查。
   - Easy to understand
     - 客户和维护人员确切知道在哪里查找ADT的规约。
     - 由于接口不包含实例字段或实例方法的实现，因此更容易将实现的细节保留在规范之外。
   - Ready for change
     - 通过添加实现接口的类，我们可以轻松地添加新类型的实现。
     - 如果我们避免使用静态工厂方法的构造函数，客户端将只能看到该接口。
     - 这意味着我们可以切换客户端正在使用的实现类，而无需更改其代码。

## 1.4 抽象类

1. 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
2. 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。
3. 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
4. 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。
5. 如果一个类包含抽象方法，那么该类必须是抽象类。
6. 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。
7. 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。

# 二、面向对象编程的不同特征

## 2.1 封装(encapsulation)

1. 封装是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。
2. 设计良好的代码隐藏了所有的实现细节
   - 干净地将API与实施分开
   - 模块只能通过API进行通信
   - 对彼此的内在运作不了解
3. 信息封装的好处
   - 将构成系统的类分开，减少耦合
   - 加快系统开发速度
   - 减轻了维护的负担
   - 启用有效的性能调整
   - 增加软件复用
4. 信息隐藏接口
   - 使用接口类型声明变量
   - 客户端仅使用接口中定义的方法
   - 客户端代码无法直接访问属性
5. 实现封装的方法
   - 修改属性的可见性来限制对属性的访问（一般限制为private)
   - 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。采用 this 关键字解决类实例变量和局部变量（set方法传入的变量）之间发生的同名的冲突。

## 2.2 继承与重写

1. 继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
2. 重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
3. 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
4. 实际执行时调用那种方法，在运行时决定
5. 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
6. 子类只能添加新方法，无法重写超类中的方法。
7. 当子类包含一个覆盖超类方法的方法时，它也可以使用关键字super调用超类方法。示例及输出如下：
<center>
<img src="https://img-blog.csdnimg.cn/20200411220302603.png" width="80%" height="35%">
</center>
<center>
<img src="https://img-blog.csdnimg.cn/20200411220348480.png" width="60%" height="35%">
</center>
<center>
图2-1 super关键字使用示例
</center>
<br>

8. 方法重写的规则
   - 参数列表必须完全与被重写方法的相同；
   - 返回类型必须完全与被重写方法的返回类型相同；
   - 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
   - 父类的成员方法只能被它的子类重写。
   - 声明为final的方法不能被重写。
   - 声明为static的方法不能被重写，但是能够被再次声明。
   - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
   - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
   - 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
   - 构造方法不能被重写。
   - 如果不能继承一个方法，则不能重写这个方法。

## 2.3 多态与重载

1. 多态是同一行为具有多种不同表现形式或形态的能力
2. 三种类型的多态
   - Ad hoc polymorphism (特殊多态)：功能重载，一个函数可以有多个同名的实现。
   - Parametric polymorphism (参数多态): 泛型或泛型编程，一个类型名字可以代表多个类型
   - Subtyping (also called subtype polymorphism or inclusion polymorphism 子类型多态、包含多态):当一个名称表示许多不同的类与一些常见的超类相关的实例。
  
<center>
<img src="https://img-blog.csdnimg.cn/20200411220905477.png" width="100%" height="35%">
</center>
<center>
图2-2 特殊多态
</center>
<br>
<center>
<img src="https://img-blog.csdnimg.cn/20200411221346738.png" width="100%" height="35%">
</center>
<center>
图2-3 参数多态性和泛型编程
</center>
<br>

3. 重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同。
4. 每个重载的方法（或构造函数）都必须有一个独一无二的参数类型列表。
5. 价值：方便client调用，client可用不同的参数列表，调用同样的函数。
6. 重载是静态多态，根据参数列表进行最佳匹配。在编译阶段时决定要具体执行哪个方法 (static type checking) ，与之相反，重构方法则是在run-time进行dynamic checking！
7. 重载规则
   - 被重载的方法必须改变参数列表(参数个数或类型不一样)；
   - 被重载的方法可以改变返回类型；
   - 被重载的方法可以改变访问修饰符；
   - 被重载的方法可以声明新的或更广的检查异常；
   - 方法能够在同一个类中或者在一个子类中被重载。
   - 无法以返回值类型作为重载函数的区分标准。

## 2.4 重写与重载的区别
| 区别点 | 重载方法 | 重写方法 |
|--|--|--|
| 参数列表 | 必须修改 | 一定不能修改 |
| 返回类型 | 可以修改 | 一定不能修改 |
| 异常 | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问 | 可以修改 | 一定不能做更严格的限制（可以降低限制）|
| 调用情况 | 引用类型决定选择哪个重载版本（基于声明的参数类型）。 在编译时发生。 | 对象类型（换句话说，堆上实际实例的类型）决定选择哪种方法在运行时发生。 |

1. 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

2. 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
3. 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
4. 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。

<center>
<img src="https://img-blog.csdnimg.cn/20200411222011727.png" width="100%" height="35%">
</center>
<center>
图2-4 重写与重载对比
</center>
<br>

## 2.5 泛型（参数多态）

1. 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
2. 可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
3. 定义泛型方法的规则：
   - 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的\<E>）。
   - 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
   - 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
   - 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。
4. 一些细节：
   - 可以有多个类型参数：例如Map<E, F>, Map<String, Integer>
   - 通配符，只在使用泛型的时候出现，不能在定义中出现，例：List<?> list = new ArrayList\<String>();
   - 泛型类型信息被删除
   - Cannot use instanceof() to check generic type 运行时泛型消失了！
   - 无法创建通用数组

# 三、设计好的类

## 3.1 好的类具有的特点

1. 简单
2. 本质上是线程安全的
3. 可以自由分享
4. 不需要防御式拷贝
5. 优秀的building blocks

## 3.2 如何编写一个不可变的类

1. 不要提供任何mutators
2. 确保没有方法可能被覆盖
3. 使所有的fields有final修饰
4. 使所有的fields有private修饰
5. 确保任何可变组件的安全性（避免表示泄露）
6. 实现toString(), hashCode(), clone(), equals()等。
